<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Xero Search</title>
  
  <style>
    :root {
      --primary-color: #13b5ea; /* Xero blue */
      --primary-dark: #0e95c4;
      --secondary-color: #273238;
      --background-color: #f9f9f9;
      --card-background: #ffffff;
      --text-color: #333333;
      --border-color: #e2e2e2;
      --success-color: #36af47; /* Xero green */
      --error-color: #d0021b;
      --info-color: #2d9cdb;
      --warning-color: #f2c94c;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      line-height: 1.6;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }

    header {
      background-color: var(--secondary-color);
      color: white;
      padding: 1rem 0;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    header .container {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    header h1 {
      font-size: 1.5rem;
      font-weight: 600;
    }

    main {
      padding: 2rem 0;
      min-height: calc(100vh - 130px);
    }

    footer {
      background-color: var(--secondary-color);
      color: rgba(255, 255, 255, 0.7);
      padding: 1rem 0;
      font-size: 0.875rem;
      text-align: center;
    }

    /* Buttons */
    .btn {
      display: inline-block;
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
      font-weight: 600;
      text-align: center;
      transition: all 0.2s ease;
    }

    .btn.primary {
      background-color: var(--primary-color);
      color: white;
    }

    .btn.primary:hover {
      background-color: var(--primary-dark);
    }

    .btn.secondary {
      background-color: #f1f1f1;
      color: var(--secondary-color);
    }

    .btn.secondary:hover {
      background-color: #e0e0e0;
    }

    /* Messages */
    .message {
      padding: 1rem;
      border-radius: 4px;
      margin-bottom: 1.5rem;
    }

    .message.info {
      background-color: rgba(45, 156, 219, 0.1);
      border: 1px solid var(--info-color);
      color: var(--info-color);
    }

    .message.error {
      background-color: rgba(208, 2, 27, 0.1);
      border: 1px solid var(--error-color);
      color: var(--error-color);
    }

    .message.success {
      background-color: rgba(54, 175, 71, 0.1);
      border: 1px solid var(--success-color);
      color: var(--success-color);
    }

    /* Search Section */
    #search-section {
      background-color: var(--card-background);
      border-radius: 8px;
      padding: 1.5rem;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      margin-bottom: 2rem;
    }

    #search-section h2 {
      margin-bottom: 1rem;
      font-size: 1.25rem;
      color: var(--secondary-color);
    }

    .search-container {
      display: flex;
      margin-bottom: 1rem;
      gap: 0.5rem;
    }

    .search-container input {
      flex: 1;
      padding: 0.75rem;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 1rem;
    }

    .search-container input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(19, 181, 234, 0.1);
    }

    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      padding: 1rem;
      background-color: rgba(0, 0, 0, 0.02);
      border-radius: 4px;
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .filter-group label {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--secondary-color);
    }

    .filter-group select,
    .filter-group input {
      padding: 0.5rem;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      min-width: 150px;
    }

    /* Results Section */
    #results-section {
      background-color: var(--card-background);
      border-radius: 8px;
      padding: 1.5rem;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }

    .results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .results-header h2 {
      font-size: 1.25rem;
      color: var(--secondary-color);
    }

    .sorting {
      display: flex;
      gap: 0.5rem;
    }

    .sorting select {
      padding: 0.5rem;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 0.875rem;
    }

    .result-item {
      padding: 1.25rem;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      margin-bottom: 1rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .result-item:hover {
      border-color: var(--primary-color);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }

    .result-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .invoice-number {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--secondary-color);
    }

    .invoice-status {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .status-draft {
      background-color: #f3f4f6;
      color: #6b7280;
    }

    .status-submitted {
      background-color: #fef3c7;
      color: #d97706;
    }

    .status-authorised {
      background-color: #dbeafe;
      color: #2563eb;
    }

    .status-paid {
      background-color: #d1fae5;
      color: #059669;
    }

    .result-details {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 0.5rem;
      font-size: 0.875rem;
    }

    .result-details div {
      display: flex;
      flex-direction: column;
    }

    .result-details span:first-child {
      color: #6b7280;
      font-size: 0.75rem;
    }

    /* Invoice Detail Section */
    #detail-section {
      background-color: var(--card-background);
      border-radius: 8px;
      padding: 1.5rem;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }

    #back-btn {
      margin-bottom: 1.5rem;
    }

/* --- Invoice Detail View Enhancements --- */

#detail-section {
  /* Optional: Increase padding slightly if needed */
  /* padding: 2rem; */
}

/* --- Styling for Invoice Header (Invoice # / Status) --- */
.invoice-header {
   display: flex; /* Keep flex layout */
   justify-content: space-between; /* Keep space between */
   align-items: center; /* Vertically align status badge better with title */
   margin-bottom: 2rem; /* Increased space below header */
   flex-wrap: wrap; /* Allow wrapping if needed on very small screens */
   gap: 1rem; /* Add gap if header wraps */
}

.invoice-header h2 {
  font-size: 1.5rem;
  color: var(--secondary-color);
  /* No changes needed here unless desired */
}

/* --- Styling for Metadata Section (Details / Customer) --- */
.invoice-meta {
  display: grid; /* Use explicit grid */
  grid-template-columns: repeat(2, 1fr); /* Default to 2 equal columns */
  gap: 2.5rem; /* Increased gap between Details and Customer columns */
  margin-bottom: 2rem; /* Increased space below meta info block */
  padding-bottom: 1.5rem; /* Add padding below meta */
  border-bottom: 1px solid var(--border-color); /* Separator line before line items */
}

.invoice-meta-group h3 {
  margin-bottom: 0.8rem; /* Slightly more space below heading */
  color: var(--secondary-color); /* Make heading darker */
  font-size: 0.9rem; /* Slightly smaller heading */
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-weight: 600; /* Keep original weight */
}

.invoice-meta-group div {
    line-height: 1.5; /* Adjust line height for readability */
    margin-bottom: 0.4rem; /* Consistent space between meta lines */
    font-size: 0.9rem; /* Match font size */
}

/* Style the labels (strong tags) within the meta groups */
 .invoice-meta-group strong {
   color: #555; /* Make labels slightly less prominent than values */
   min-width: 85px; /* Ensure labels align somewhat */
   display: inline-block; /* Needed for min-width */
   margin-right: 0.5rem; /* Space between label and value */
   font-weight: 500; /* Less heavy font weight */
 }

/* Target the address block specifically for better formatting */
.invoice-meta-group .address-block {
    margin-top: 0.2rem; /* Add a little space above the address */
}

.invoice-meta-group .address-block span {
    display: block; /* Make each address line a block */
    margin-left: 90px; /* Indent address lines (adjust value as needed based on label width) */
    margin-top: -1.6em; /* Pull first address line up closer to "Address:" label */
    line-height: 1.4; /* Tighter line height for address */
}
/* Adjust margin-top only for the first span inside address-block */
.invoice-meta-group .address-block span:first-child {
   margin-top: -1.6em;
}
/* Reset margin-top for subsequent spans */
.invoice-meta-group .address-block span + span {
    margin-top: 0;
}

/* Hide the initial <br> after the Address label if it exists */
 .invoice-meta-group strong + br {
     display: none;
 }

/* --- Styling for Line Items Section --- */
.invoice-items {
  /* Explicitly ensure it's a block taking full width */
  display: block; /* Override any potential flex/grid context from parent */
  width: 100%;   /* Ensure the container tries to fill available width */
  box-sizing: border-box; /* Consistent width calculation */
  margin-top: 2rem; /* Space above the heading */
  /* Overflow for scrolling is handled in the media query */
}

/* Keep H3 styling as is */
.invoice-items > h3 {
   font-size: 1.25rem;
   color: var(--secondary-color);
   margin-bottom: 1.5rem;
}

/* Base style for the line items table (applies to all widths) */
.invoice-items table {
  width: 100%; /* Table fills the .invoice-items container */
  border-collapse: collapse;
  margin-bottom: 2rem;
  table-layout: fixed; /* ADDED THIS LINE - Uses fixed layout algorithm */
}

/* Keep th, td, tfoot, .text-right, .total-row styles as they are */
.invoice-items th {
  text-align: left;
  padding: 0.75rem;
  background-color: rgba(0, 0, 0, 0.02);
  font-weight: 600;
  color: var(--secondary-color);
  border-bottom: 1px solid var(--border-color);
  /* Optional: If using table-layout: fixed, you might want explicit widths */
  /* E.g., &:nth-child(1) { width: 40%; } ... etc. */
}

.invoice-items td {
  padding: 0.75rem;
  border-bottom: 1px solid var(--border-color);
  font-size: 0.875rem;
   /* Optional with table-layout: fixed - handle overflow if content is too long */
   /* overflow: hidden; */
   /* text-overflow: ellipsis; */
   /* white-space: nowrap; */
}

.invoice-items .text-right {
  text-align: right;
}

.invoice-items tfoot td {
  font-weight: 600;
}

.invoice-items .total-row {
  font-size: 1rem;
  background-color: rgba(0, 0, 0, 0.02);
}

/* --- End Invoice Detail View Layout Styles --- */


/* --- Responsive adjustments for metadata and table --- */
/* (Ensure this @media block exists or integrate these rules into your existing one) */
@media (max-width: 768px) {
  /* Stack meta section */
  .invoice-meta {
    grid-template-columns: 1fr;
    gap: 1.8rem;
  }

   /* Reset address indentation on mobile */
   .invoice-meta-group .address-block span {
       margin-left: 0;
       margin-top: 0.2rem;
   }
    .invoice-meta-group .address-block span:first-child {
       margin-top: 0.2rem;
   }

   /* Add horizontal scrolling ONLY to the container on mobile */
   .invoice-items {
      overflow-x: auto;
      padding-bottom: 10px;
      -webkit-overflow-scrolling: touch;
      /* display/width are inherited from base styles */
   }

   /* Force table minimum width ONLY on mobile to trigger scrolling */
   /* Note: table-layout: fixed might make min-width less critical, but keep for safety */
   .invoice-items table {
       min-width: 600px;
       /* width: 100% is inherited */
       /* table-layout: fixed is inherited */
   }
}
/* --- End Responsive Adjustments --- */

#pagination {
  display: flex;
  justify-content: center;
  gap: 1rem;
  margin-top: 1.5rem;
}

#pagination button {
  padding: 0.625rem 1.25rem;
  border: 1px solid var(--border-color);
  background-color: white;
  cursor: pointer;
  border-radius: 4px;
  font-size: 0.875rem;
  min-width: 120px;
  font-weight: 500;
  transition: all 0.2s ease;
}

#pagination button:hover {
  border-color: var(--primary-color);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

#pagination button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

#pagination button:first-child {
  border-color: var(--border-color);
}

#pagination button:last-child {
  background-color: var(--primary-color);
  color: white;
  border-color: var(--primary-color);
}

#pagination button:last-child:hover {
  background-color: var(--primary-dark);
}

    /* Loading spinner */
    #loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(19, 181, 234, 0.2);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 0.8s linear infinite;
      margin-bottom: 1rem;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Utility classes */
    .hidden {
      display: none !important;
    }

    /* Responsive styles */
    @media (max-width: 768px) {
      header .container {
        flex-direction: column;
        text-align: center;
        gap: 1rem;
      }
      
      .search-container {
        flex-direction: column;
      }
      
      .results-header {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .sorting {
        width: 100%;
      }
      
      .sorting select {
        flex: 1;
      }
      
      .invoice-meta {
        grid-template-columns: 1fr;
      }
      
      .invoice-items {
        overflow-x: auto;
      }
    }

    /* Tenant selection dropdown */
.tenant-select {
  margin-left: 10px;
  padding: 3px 6px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 4px;
  background-color: rgba(255, 255, 255, 0.1);
  color: white;
  font-size: 0.85rem;
}

.tenant-select:focus {
  outline: none;
  border-color: var(--primary-color);
}

#user-section {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 10px;
}

#user-info {
  display: flex;
  flex-direction: column;
  min-width: 200px;
  margin-right: 15px;
}

/* Job status indicators */
.job-age {
  display: inline-block;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.75rem;
  margin-top: 0.5rem;
}

.job-recent {
  background-color: #e6f7ff;
  color: #0070d1;
}

.job-approaching {
  background-color: #fff7e6;
  color: #d46b08;
}

.job-overdue {
  background-color: #fff1f0;
  color: #cf1322;
  font-weight: bold;
}

/* Highlight overdue items */
.result-item.overdue {
  border-left: 3px solid #cf1322;
}

.result-item.approaching {
  border-left: 3px solid #d46b08;
}

/* Add this CSS inside your <style> tag */
  #results-section {
  transition: opacity 0.3s ease;
}

#results-list {
  transition: opacity 0.2s ease;
}

.loading-indicator {
  display: flex;
  justify-content: center;
  padding: 20px;
}

/* --- Invoice Detail View Enhancements --- */

#detail-section {
  /* Optional: Increase padding slightly if needed */
  /* padding: 2rem; */
}

.invoice-header {
   margin-bottom: 2rem; /* Increase space below header */
   align-items: center; /* Vertically align status badge better with title */
   flex-wrap: wrap; /* Allow wrapping if needed on very small screens */
   gap: 1rem; /* Add gap if header wraps */
}

.invoice-meta {
  display: grid; /* Use explicit grid */
  grid-template-columns: repeat(2, 1fr); /* Default to 2 equal columns */
  gap: 2.5rem; /* Increase gap between Details and Customer columns */
  margin-bottom: 2rem; /* Increase space below meta info block */
  padding-bottom: 1.5rem; /* Add padding below meta */
  border-bottom: 1px solid var(--border-color); /* Separator line before line items */
}

.invoice-meta-group h3 {
  margin-bottom: 0.8rem; /* Slightly more space below heading */
  color: var(--secondary-color); /* Make heading darker */
  font-size: 0.9rem; /* Slightly smaller heading */
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.invoice-meta-group div {
    line-height: 1.5; /* Adjust line height for readability */
    margin-bottom: 0.4rem; /* Consistent space between meta lines */
    font-size: 0.9rem; /* Match font size */
}

/* Style the labels within the meta groups */
 .invoice-meta-group strong {
   color: #555; /* Make labels slightly less prominent than values */
   min-width: 85px; /* Ensure labels align somewhat */
   display: inline-block; /* Needed for min-width */
   margin-right: 0.5rem; /* Space between label and value */
   font-weight: 500; /* Less heavy font weight */
 }

/* Target the address block specifically for better formatting */
.invoice-meta-group .address-block {
    margin-top: 0.2rem; /* Add a little space above the address */
}

.invoice-meta-group .address-block span {
    display: block; /* Make each address line a block */
    margin-left: 90px; /* Indent address lines (adjust value as needed based on label width) */
    margin-top: -1.6em; /* Pull first address line up closer to "Address:" label */
    line-height: 1.4; /* Tighter line height for address */
}
/* Adjust margin-top only for the first span inside address-block */
.invoice-meta-group .address-block span:first-child {
   margin-top: -1.6em;
}
/* Reset margin-top for subsequent spans */
.invoice-meta-group .address-block span + span {
    margin-top: 0;
}

/* Hide the initial <br> after the Address label if it exists */
 .invoice-meta-group strong + br {
     display: none;
 }


.invoice-items {
  /* This section contains the table */
  margin-top: 2rem; /* Ensure space above line items */
}

.invoice-items > h3 { /* Target only the H3 directly inside .invoice-items */
   font-size: 1.25rem;
   color: var(--secondary-color);
   margin-bottom: 1.5rem; /* More space below "Line Items" heading */
}

/* Responsive adjustments for metadata layout */
@media (max-width: 768px) {
  .invoice-meta {
    grid-template-columns: 1fr; /* Stack to 1 column */
    gap: 1.8rem; /* Adjust gap for stacked layout */
  }

   /* Remove address indentation on mobile for simpler layout */
   .invoice-meta-group .address-block span {
       margin-left: 0;
       margin-top: 0.2rem; /* Reset margin-top */
   }
    .invoice-meta-group .address-block span:first-child {
       margin-top: 0.2rem; /* Ensure first line also has normal spacing */
   }
}

/* Ensure table scrolling is applied robustly */
@media (max-width: 768px) {
    .invoice-items {
      overflow-x: auto; /* Essential for preventing table breaking layout */
      padding-bottom: 10px; /* Add some padding so scrollbar isn't tight against table */
      -webkit-overflow-scrolling: touch; /* Smoother scrolling on iOS */
    }
    .invoice-items table {
        min-width: 600px; /* Force table to a min-width to necessitate scrolling */
        width: 100%; /* Prevent table from shrinking below min-width */
    }
}
/* --- End Invoice Detail View Enhancements --- */

/* --- Autocomplete Styles --- */
.search-container {
  position: relative; /* Needed for absolute positioning of suggestions */
}

.autocomplete-items {
  position: absolute;
  border: 1px solid var(--border-color);
  border-top: none;
  background-color: var(--card-background);
  z-index: 99;
  /* Position it below the input */
  top: 100%; /* Start right below the container */
  left: 0;
  right: 0;
  max-height: 250px; /* Limit height and add scroll */
  overflow-y: auto;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  border-bottom-left-radius: 4px;
  border-bottom-right-radius: 4px;
}

.autocomplete-items div {
  padding: 0.75rem;
  cursor: pointer;
  border-bottom: 1px solid var(--border-color);
  font-size: 0.9rem;
}
.autocomplete-items div:last-child {
  border-bottom: none; /* Remove border from last item */
}

.autocomplete-items div:hover {
  background-color: #e9e9e9;
}

/* Style for highlighting the matching part (optional) */
.autocomplete-items div strong {
  font-weight: 600;
  color: var(--primary-dark);
}

/* --- End Autocomplete Styles --- */

  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>Xero Search</h1>
      <div id="user-section">
        <div id="tenant-selector" class="hidden" style="margin-right: 15px; display: flex; align-items: center;">
          <select id="tenant-dropdown" style="margin-left: 8px; padding: 4px; border-radius: 4px; background-color: #fff; color: #333;">
            <!-- Options will be added via JavaScript -->
          </select>
        </div>
        <button id="clear-cookies-btn" class="btn secondary" style="margin-right: 10px;">Reset Connection</button>
        <button id="login-btn" class="btn primary">Connect to Xero</button>
        <button id="logout-btn" class="btn secondary hidden">Disconnect</button>
      </div>
    </div>
  </header>

  <main class="container">
    <!-- Authentication message -->
    <div id="auth-message" class="message info">
      <p>Please connect to Xero to access your invoices.</p>
    </div>

    <!-- Search Section -->
    <section id="search-section" class="hidden">
      <h2>Search Invoices</h2>
      <div class="search-container">
        <input 
          type="text" 
          id="search-input" 
          placeholder="Search by invoice number, reference, or customer name..."
        >
        <div id="autocomplete-suggestions" class="autocomplete-items hidden"></div>
        <button id="search-btn" class="btn primary">Search</button>
      </div>
      
      <div class="filters">
        <div class="filter-group">
          <label for="job-status-filter">Job Status:</label>
          <select id="job-status-filter">
            <option value="">All Invoices</option>
            <option value="approaching">Borderline (7-10 days)</option>
            <option value="overdue">Deadline (10+ days)</option>
          </select>
        </div>
        <!-- Date pickers removed -->
      </div>
    </section>

    <!-- Loading Indicator -->
    <div id="loading" class="hidden">
      <div class="spinner"></div>
      <p>Loading invoices...</p>
    </div>

    <!-- Results Section -->
    <section id="results-section" class="hidden">
      <div class="results-header">
        <h2>Search Results <span id="results-count">(0)</span></h2>
        <div class="sorting">
          <select id="sort-by">
            <option value="Date-desc">Sort by latest</option>
            <option value="Date-asc">Sort by oldest</option>
            <option value="Contact.Name-asc">Sort by customer</option>
            <option value="InvoiceNumber-asc">Sort by invoice number</option>
          </select>
        </div>
      </div>
      
      <div id="results-list"></div>
      
<!-- NEW CODE - Replace with this section -->
<div id="pagination" style="display: flex; justify-content: center; margin-top: 1.5rem;"></div>
    </section>

    <!-- Invoice Detail View -->
    <section id="detail-section" class="hidden">
      <button id="back-btn" class="btn secondary">← Back to Results</button>
      <div id="invoice-detail"></div>
    </section>

    <!-- Error Message -->
    <div id="error-message" class="message error hidden"></div>
  </main>

  <footer>
    <div class="container">
      <p>Xero Search App | Powered by Xero API</p>
    </div>
  </footer>

  <!-- Main JavaScript -->
  <script>
  // Initialize the application

  // Initialize the application
function initApp() {
  console.log("Initializing app...");

  // Initialize caching variables and state BEFORE checking auth
  cachedPages = {}; // Reset cache on app start
  window.lastPageViewed = 1; // Reset page tracking
  window.lastScrollPosition = 0; // Reset scroll tracking
  currentResults = []; // Clear previous results
  window.filteredResults = null; // Clear filters
  currentPage = 1; // Reset to first page
  window.tenantId = null; // Ensure tenantId is null initially
  window.tenantName = null;
  window.xeroTenants = null;


  // Check for authentication result in URL parameters FIRST
  // This might set auth state and initial tenant from URL redirect
  checkAuthResult();

  // Check if we're already authenticated (reads from localStorage)
  // This confirms auth state and ensures tenant ID/list are loaded into window vars
  // It also calls displayTenantDropdown if authenticated
  checkAuthStatus();

  // Set up event listeners AFTER potential UI updates from checkAuthStatus
  setupEventListeners();

  // Load initial invoices *only if* authenticated and tenant is set
  // checkAuthStatus now handles setting window.tenantId correctly
  if (localStorage.getItem('xero_authenticated') === 'true' && window.tenantId) {
      console.log(`Authentication confirmed. Triggering initial invoice load for tenant: ${window.tenantName} (${window.tenantId})`);
      // Reset filters before initial load
        document.getElementById('job-status-filter').value = '';
        document.getElementById('search-input').value = '';
      loadInitialInvoices();
  } else {
       console.log("Skipping initial invoice load: Not authenticated or no tenant ID determined.");
       // Ensure UI reflects logged-out state if needed
       updateUI(false);
       document.getElementById('auth-message').classList.remove('hidden'); // Show connect message
  }
}

// Check for auth result in URL parameters
function checkAuthResult() {
  const urlParams = new URLSearchParams(window.location.search);
  const authStatus = urlParams.get('auth');
  const errorMessage = urlParams.get('message');
  const tenantNameParam = urlParams.get('tenantName'); // Renamed to avoid conflict
  const tenantIdParam = urlParams.get('tenantId'); // Renamed to avoid conflict
  const multipleOrgs = urlParams.get('multipleOrgs') === 'true';
  const tenantsParam = urlParams.get('tenants');
  const tokensParam = urlParams.get('tokens');

  // Process auth status from URL
  if (authStatus === 'success') {
    console.log("Authentication successful");
    localStorage.setItem('xero_authenticated', 'true');

    // --- START MODIFIED CODE for tenant handling ---
    let determinedTenantId = tenantIdParam; // From URL param
    let determinedTenantName = tenantNameParam; // From URL param
    let tenantsList = [];

    // Process tenants data if available
    if (tenantsParam) {
      try {
        tenantsList = JSON.parse(decodeURIComponent(tenantsParam));
        console.log('Received tenants data:', tenantsList);
        localStorage.setItem('xero_tenants', JSON.stringify(tenantsList));
        window.xeroTenants = tenantsList;

        if (tenantsList.length > 0) {
            // If multiple orgs, the URL might not contain a specific tenantId/Name,
            // so default to the first one in the list as the initially active one.
             if (!determinedTenantId) {
                determinedTenantId = tenantsList[0].tenantId;
                determinedTenantName = tenantsList[0].tenantName;
                console.log("Multiple orgs detected, defaulting initial tenant to first in list:", determinedTenantId);
             }
        }

      } catch (error) {
        console.error('Error parsing tenants data:', error);
        // If tenants list fails to parse but we got a single ID/Name, use that
        if (determinedTenantId) {
             tenantsList = [{ tenantId: determinedTenantId, tenantName: determinedTenantName || 'Unknown' }];
             window.xeroTenants = tenantsList;
             localStorage.setItem('xero_tenants', JSON.stringify(tenantsList));
        }
      }
    } else if (determinedTenantId) {
        // Only a single tenant ID/Name came back, create minimal tenants list
         tenantsList = [{ tenantId: determinedTenantId, tenantName: determinedTenantName || 'Unknown' }];
         window.xeroTenants = tenantsList;
         localStorage.setItem('xero_tenants', JSON.stringify(tenantsList));
         console.log("Single tenant detected:", determinedTenantId);
    } else {
        console.error("Authentication success but no tenant information received!");
        showError("Connected to Xero, but couldn't identify your organization. Please try reconnecting.");
        clearCookies(); // Clear partial auth state
        updateUI(false);
        return; // Stop processing if no tenant info
    }

    // Now, store the determined initially active tenant
    if (determinedTenantId) {
        localStorage.setItem('xero_tenant_id', determinedTenantId);
        localStorage.setItem('xero_tenant_name', determinedTenantName || 'Unknown Organization');
        window.tenantId = determinedTenantId; // Set window variable for current session
        window.tenantName = determinedTenantName || 'Unknown Organization';
        console.log(`Initial active tenant set to: ${window.tenantName} (${window.tenantId})`);
    } else {
        console.error("Failed to determine an active tenant ID after processing auth results.");
         showError("Failed to set an active organization. Please reconnect.");
         clearCookies();
         updateUI(false);
         return;
    }
     // Display dropdown immediately after getting tenants list
     if (window.xeroTenants && window.xeroTenants.length > 0) {
        displayTenantDropdown(window.xeroTenants);
    }
    // --- END MODIFIED CODE for tenant handling ---


    // Process tokens data if available
    if (tokensParam) {
      try {
        const tokens = JSON.parse(decodeURIComponent(tokensParam));
        console.log('Received tokens data with expiration at:', new Date(tokens.expires_at).toLocaleString());
        localStorage.setItem('xero_tokens', JSON.stringify(tokens));
        window.xeroTokens = tokens;
      } catch (error) {
        console.error('Error parsing tokens data:', error);
        // Decide if this is critical. Maybe allow continuing but warn?
        showError("Connected, but failed to store authentication tokens. You may need to reconnect soon.");
      }
    } else {
        // This is more critical, auth won't work without tokens
        console.error("Authentication success but no tokens received!");
        showError("Authentication succeeded but token data is missing. Please try reconnecting.");
        clearCookies();
        updateUI(false);
        return; // Stop processing if no tokens
    }

    showSuccess(`Successfully connected to Xero${window.tenantName ? `: ${window.tenantName}` : ''}`);
    updateUI(true); // Update UI to authenticated state

    // If multiple organizations, show a message
    if (multipleOrgs || (tenantsList && tenantsList.length > 1)) {
      showMessage("You have access to multiple Xero organizations. Use the dropdown to switch between them.", "info");
    }

    // Initial load is handled in initApp

  } else if (authStatus === 'error' && errorMessage) {
    console.error("Authentication error:", errorMessage);
    showError(`Xero connection failed: ${decodeURIComponent(errorMessage)}`);
    clearCookies(); // Clear any partial auth state
    updateUI(false);
  }

  // Clean up URL parameters regardless of success/error
  if (authStatus) {
    // Remove query parameters but keep the path
    const currentPath = window.location.pathname;
    window.history.replaceState({}, document.title, currentPath);
  }
}

// Check if we're already authenticated - using localStorage approach
function checkAuthStatus() {
  console.log("Checking authentication status...");

  // Check if we're authenticated via localStorage
  const isAuthenticated = localStorage.getItem('xero_authenticated') === 'true';
  console.log("Is authenticated (localStorage):", isAuthenticated);

  if (isAuthenticated) {
    console.log("User is authenticated");

    // --- START MODIFIED CODE ---
    // Get tenant information CONSISTENTLY from localStorage
    const tenantId = localStorage.getItem('xero_tenant_id');
    const tenantName = localStorage.getItem('xero_tenant_name');
    // --- END MODIFIED CODE ---

    if (tenantId) {
      console.log(`Using tenant from localStorage: ${tenantName} (${tenantId})`);
      window.tenantId = tenantId;
      window.tenantName = tenantName || 'Your Xero Organization';

      // Get tenants list from localStorage if available
      const storedTenants = localStorage.getItem('xero_tenants');
      if (storedTenants) {
        try {
          window.xeroTenants = JSON.parse(storedTenants);
          // Ensure the current tenantId is actually in the list
           const currentTenantInList = window.xeroTenants.find(t => t.tenantId === window.tenantId);
           if (!currentTenantInList && window.xeroTenants.length > 0) {
               console.warn(`Current tenant ${window.tenantId} not in stored list. Defaulting to first tenant.`);
               window.tenantId = window.xeroTenants[0].tenantId;
               window.tenantName = window.xeroTenants[0].tenantName;
               localStorage.setItem('xero_tenant_id', window.tenantId);
               localStorage.setItem('xero_tenant_name', window.tenantName);
           }

        } catch (e) {
            console.error("Error parsing stored tenants", e);
          // Fallback if tenants list is corrupted but we have a tenantId/Name
          window.xeroTenants = [{
            tenantId: window.tenantId,
            tenantName: window.tenantName
          }];
        }
      } else {
        // Fallback to single tenant if no list stored
        window.xeroTenants = [{
          tenantId: window.tenantId,
          tenantName: window.tenantName
        }];
         localStorage.setItem('xero_tenants', JSON.stringify(window.xeroTenants)); // Store it now
      }

      displayTenantDropdown(window.xeroTenants || []); // Pass tenants list
      updateUI(true);

      // Initial load is now handled in initApp after this function runs

    } else {
      console.warn("Authenticated but no tenant ID found in localStorage.");
      // Attempt to get tenant info from stored list if available
      const storedTenants = localStorage.getItem('xero_tenants');
       if (storedTenants) {
           try {
               const tenants = JSON.parse(storedTenants);
               if (tenants && tenants.length > 0) {
                   console.log("No tenant ID stored, defaulting to first tenant from list.");
                   window.tenantId = tenants[0].tenantId;
                   window.tenantName = tenants[0].tenantName;
                   localStorage.setItem('xero_tenant_id', window.tenantId);
                   localStorage.setItem('xero_tenant_name', window.tenantName);
                   window.xeroTenants = tenants;
                   displayTenantDropdown(window.xeroTenants);
                   updateUI(true);
                   // Initial load will now proceed in initApp
                   return; // Exit checkAuthStatus early as we recovered
               }
           } catch(e) { /* ignore parse error if list is corrupt */ }
       }
      // If still no tenant ID, show error
      showError("No Xero organization selected. Please try reconnecting to Xero.");
      updateUI(false); // Stay logged out visually
      clearCookies(); // Clear potentially inconsistent state
    }
  } else {
    console.log("User is not authenticated");
    updateUI(false);
  }
}

// Display tenant dropdown selector - fixed version
function displayTenantDropdown(tenants) {
  console.log('Displaying tenant dropdown with:', tenants);

  // Get dropdown element
  const dropdown = document.getElementById('tenant-dropdown');

  // Clear existing options
  dropdown.innerHTML = '';

  // Add options for each tenant
  tenants.forEach(tenant => {
    const option = document.createElement('option');
    option.value = tenant.tenantId;
    option.textContent = tenant.tenantName || 'Unnamed Organization';
    dropdown.appendChild(option);
  });

  // --- START NEW CODE in this function ---
  // Ensure the dropdown selection matches the current active tenant ID
  if (window.tenantId) {
    // Check if the current window.tenantId exists in the dropdown options
    const tenantExists = Array.from(dropdown.options).some(opt => opt.value === window.tenantId);
    if (tenantExists) {
        dropdown.value = window.tenantId;
        console.log(`Set dropdown value to match active tenant: ${window.tenantId}`);
    } else if (tenants.length > 0) {
        // If the stored tenantId is invalid/not in list, default to the first one
        window.tenantId = tenants[0].tenantId;
        window.tenantName = tenants[0].tenantName;
        dropdown.value = window.tenantId;
        localStorage.setItem('xero_tenant_id', window.tenantId);
        localStorage.setItem('xero_tenant_name', window.tenantName);
        console.log(`Stored tenant ID was invalid, defaulted active tenant to first in list: ${window.tenantId}`);
    }
    
  } else if (tenants.length > 0) {
    // If no specific tenantId is set in window, default to the first one
    window.tenantId = tenants[0].tenantId;
    window.tenantName = tenants[0].tenantName;
    dropdown.value = window.tenantId;
    // Optionally store this default selection
    localStorage.setItem('xero_tenant_id', window.tenantId);
    localStorage.setItem('xero_tenant_name', window.tenantName);
    console.log(`No active tenant set, defaulted active tenant to first in list: ${window.tenantId}`);
  }
  // --- END NEW CODE in this function ---

  // Always show the selector if we have at least one tenant
  if (tenants && tenants.length > 0) {
    document.getElementById('tenant-selector').classList.remove('hidden');

    // Attach the change listener *only once*
    if (!dropdown.dataset.listenerAttached) { // Simple way to prevent multiple listeners
        dropdown.addEventListener('change', handleTenantChange);
        dropdown.dataset.listenerAttached = 'true'; // Mark as attached
        console.log('Tenant dropdown change listener attached.');
    }

  } else {
    document.getElementById('tenant-selector').classList.add('hidden');
  }
}

// NEW CODE: Separate handler function for clarity
function handleTenantChange() {
  const dropdown = document.getElementById('tenant-dropdown');
  window.tenantId = dropdown.value;
  window.tenantName = dropdown.options[dropdown.selectedIndex].textContent;
  console.log(`Switched to organization: ${window.tenantName} (${window.tenantId})`);

  // --- START MODIFIED CODE ---
  // Save selected tenant consistently to localStorage
  localStorage.setItem('xero_tenant_id', window.tenantId);
  localStorage.setItem('xero_tenant_name', window.tenantName);
  // --- END MODIFIED CODE ---

  // Reset all data and caches
  currentResults = [];
  currentPage = 1;
  cachedPages = {}; // Crucial: Clear cache on tenant switch
  window.filteredResults = null;

  // Clear results display
  document.getElementById('results-list').innerHTML = '';
  document.getElementById('results-count').textContent = '(0)';
  document.getElementById('pagination').innerHTML = ''; // Clear pagination

  // Show a loading indicator while fetching new data
  toggleLoading(true); // Ensure loading is shown

  // Reset any active filters
  document.getElementById('job-status-filter').value = '';
  document.getElementById('search-input').value = '';


  // Reload invoices for the new organization
  loadInitialInvoices(); // This should now use the updated window.tenantId

  // Show a message to the user
  showMessage(`Switched to ${window.tenantName}. Loading invoices...`, 'info');
}

// NEW CODE: Separate handler function for clarity
function handleTenantChange() {
  const dropdown = document.getElementById('tenant-dropdown');
  window.tenantId = dropdown.value;
  window.tenantName = dropdown.options[dropdown.selectedIndex].textContent;
  console.log(`Switched to organization: ${window.tenantName} (${window.tenantId})`);

  // --- START MODIFIED CODE ---
  // Save selected tenant consistently to localStorage
  localStorage.setItem('xero_tenant_id', window.tenantId);
  localStorage.setItem('xero_tenant_name', window.tenantName);
  // Remove the cookie setting lines if you want to use localStorage exclusively
  // document.cookie = `xero_tenant_id=${window.tenantId}; path=/; secure; samesite=lax`;
  // document.cookie = `xero_tenant_name=${window.tenantName}; path=/; secure; samesite=lax`;
  // --- END MODIFIED CODE ---

  // Reset all data and caches
  currentResults = [];
  currentPage = 1;
  cachedPages = {}; // Crucial: Clear cache on tenant switch
  window.filteredResults = null;

  // Clear results display
  document.getElementById('results-list').innerHTML = '';
  document.getElementById('results-count').textContent = '(0)';
  document.getElementById('pagination').innerHTML = ''; // Clear pagination

  // Show a loading indicator while fetching new data
  toggleLoading(true); // Ensure loading is shown

  // Reset any active filters
  document.getElementById('job-status-filter').value = '';
  document.getElementById('search-input').value = '';

  // Reload invoices for the new organization
  loadInitialInvoices(); // This should now use the updated window.tenantId

  // Show a message to the user
  showMessage(`Switched to ${window.tenantName}. Loading invoices...`, 'info');
}

// Setup event listeners - simplified
function setupEventListeners() {
  // Login button
  document.getElementById('login-btn').addEventListener('click', () => {
    console.log("Connect to Xero button clicked");
    window.location.href = '/.netlify/functions/xero-auth';
  });
  
  // Logout button
  document.getElementById('logout-btn').addEventListener('click', () => {
    clearCookies();
    window.location.reload();
  });
  
  // Clear cookies button
  document.getElementById('clear-cookies-btn').addEventListener('click', () => {
    clearCookies();
    showSuccess('All cookies cleared');
    updateUI(false);
  });
  
  // Search button
  document.getElementById('search-btn').addEventListener('click', searchInvoices);
  
  // Search input - enter key
  document.getElementById('search-input').addEventListener('keypress', event => {
    if (event.key === 'Enter') {
      searchInvoices();
    }
  });

    // Autocomplete listener with debounce
    const searchInput = document.getElementById('search-input');
  const debouncedAutocomplete = debounce(handleAutocomplete, DEBOUNCE_DELAY);
  searchInput.addEventListener('input', debouncedAutocomplete);

  // Hide suggestions on blur (losing focus), but delay slightly
  // This allows a click on a suggestion to register first
  searchInput.addEventListener('blur', () => {
      setTimeout(() => {
          const suggestionsContainer = document.getElementById('autocomplete-suggestions');
           if (!suggestionsContainer.matches(':hover')) { // Don't hide if mouse is over suggestions
              suggestionsContainer.innerHTML = '';
              suggestionsContainer.classList.add('hidden');
           }
      }, 150); // Delay ms
  });

  // Ensure suggestions are shown when input gets focus back and has text
   searchInput.addEventListener('focus', () => {
       if (searchInput.value.trim().length > 0) {
           handleAutocomplete(); // Re-show suggestions if there's text
       }
   });

// Job status filter change
document.getElementById('job-status-filter').addEventListener('change', async function() {
  const selectedStatus = this.value;
  toggleLoading(true);
  
  try {
    if (selectedStatus) {
      // For any job status filter, we'll load specific data
      await loadInvoicesByStatus(selectedStatus);
    } else {
      // Show all results (no job status filter)
      window.filteredResults = null;
      document.getElementById('results-count').textContent = `(${currentResults.length})`;
      sortResults(); // This will redisplay all results
    }
  } catch (error) {
    console.error("Error applying job status filter:", error);
    showError("Error loading invoices. Please try again.");
  } finally {
    toggleLoading(false);
  }
});
  
 // Sort options
document.getElementById('sort-by').addEventListener('change', () => {
  console.log('Sort by changed');
  sortResults();
});

  
  // Back button (invoice details)
  document.getElementById('back-btn').addEventListener('click', () => {
    document.getElementById('detail-section').classList.add('hidden');
    document.getElementById('results-section').classList.remove('hidden');
  });
  
}

// Check if tokens need refreshing
async function checkAndRefreshTokens() {
  console.log("Checking if tokens need refreshing...");
  
  // Get tokens from localStorage
  const tokensJson = localStorage.getItem('xero_tokens');
  if (!tokensJson) {
    console.warn("No tokens found in localStorage");
    return null;
  }
  
  try {
    const tokens = JSON.parse(tokensJson);
    const currentTime = Date.now();
    const expiresAt = tokens.expires_at;
    
    // If token expiration is less than 5 minutes away, refresh it
    if (expiresAt - currentTime < 5 * 60 * 1000) {
      console.log("Token expiring soon, refreshing...");
      return await refreshTokens(tokens.refresh_token);
    }
    
    // Token is still valid
    console.log("Token is still valid until:", new Date(expiresAt).toLocaleString());
    return tokens;
  } catch (error) {
    console.error("Error checking tokens:", error);
    return null;
  }
}

// Refresh tokens
async function refreshTokens(refreshToken) {
  console.log("Refreshing tokens...");
  
  try {
    const response = await fetch('/api/xero-refresh', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        refresh_token: refreshToken
      })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Server returned ${response.status}`);
    }
    
    const newTokens = await response.json();
    console.log("Tokens refreshed successfully");
    
    // Update localStorage and window.xeroTokens
    localStorage.setItem('xero_tokens', JSON.stringify(newTokens));
    window.xeroTokens = newTokens;
    
    return newTokens;
  } catch (error) {
    console.error("Error refreshing tokens:", error);
    showError('Authentication expired. Please reconnect to Xero.');
    clearCookies();
    updateUI(false);
    return null;
  }
}

// Get current valid tokens
async function getValidTokens() {
  return await checkAndRefreshTokens();
}

// Clear authentication data (cookies and localStorage)
function clearCookies() {
  // Clear cookies (keep for potential other uses, but primary auth is localStorage now)
  document.cookie = "xero_authenticated=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; secure; samesite=lax";
  document.cookie = "xero_tenant_id=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; secure; samesite=lax";
  document.cookie = "xero_tenant_name=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; secure; samesite=lax";
  document.cookie = "xero_user_id=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; secure; samesite=lax";

  // Clear localStorage items used for auth and tenant management
  localStorage.removeItem('xero_authenticated');
  localStorage.removeItem('xero_tenant_id'); // Ensure this is cleared
  localStorage.removeItem('xero_tenant_name'); // Ensure this is cleared
  localStorage.removeItem('xero_tenants');
  localStorage.removeItem('xero_tokens');

  // Clear window variables
  window.tenantId = null;
  window.tenantName = null;
  window.xeroTenants = null;
  window.xeroTokens = null;

  // Reset UI elements
  const dropdown = document.getElementById('tenant-dropdown');
  if (dropdown) {
      dropdown.innerHTML = ''; // Clear dropdown options
      dropdown.dataset.listenerAttached = 'false'; // Reset listener flag if used
  }
   document.getElementById('tenant-selector').classList.add('hidden'); // Hide selector

   // Reset other parts of UI if necessary
    document.getElementById('results-list').innerHTML = '';
    document.getElementById('results-count').textContent = '(0)';
    document.getElementById('pagination').innerHTML = '';
    document.getElementById('detail-section').classList.add('hidden');
    document.getElementById('results-section').classList.add('hidden');
    document.getElementById('search-section').classList.add('hidden'); // Hide search section


  console.log('All Xero authentication data cleared from localStorage and cookies.');
}

/**
 * Extracts the first sequence of exactly 6 digits from a string.
 * @param {string} text The string to search within.
 * @returns {string|null} The 6-digit number as a string, or null if not found.
 */
 function extractSixDigitInvoiceNumber(text) {
  if (!text) {
    return null; // Return null if the input is empty or null
  }
  // Regex to find exactly 6 consecutive digits
  const regex = /\d{6}/;
  const match = text.match(regex);

  // Return the first match found, or null otherwise
  return (match && match[0]) ? match[0] : null;
}

// Cookie helper functions
function getCookie(name) {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) {
    const cookieValue = parts.pop().split(';').shift();
    // Check for "undefined" string value
    return cookieValue === "undefined" ? null : cookieValue;
  }
  return null;
}

// Toggle loading state
function toggleLoading(show) {
  document.getElementById('loading').classList.toggle('hidden', !show);
}

// Enhanced error message display
function showError(message, autoHide = true) {
  const messageElement = document.getElementById('error-message');
  messageElement.textContent = message;
  messageElement.className = 'message error';
  messageElement.classList.remove('hidden');
  
  if (autoHide) {
    // Auto-hide after 8 seconds for errors
    setTimeout(() => {
      messageElement.classList.add('hidden');
    }, 8000);
  }
  
  // Log errors to console for debugging
  console.error("Error:", message);
}

// Show success message
function showSuccess(message) {
  showMessage(message, 'success');
}

// Show message with type
function showMessage(message, type = 'info') {
  const messageElement = document.getElementById('error-message');
  messageElement.textContent = message;
  messageElement.className = `message ${type}`;
  messageElement.classList.remove('hidden');
  
  // Auto-hide after 5 seconds
  setTimeout(() => {
    messageElement.classList.add('hidden');
  }, 5000);
}

// Update UI based on authentication state - fixed version
function updateUI(isAuthenticated) {
  console.log('Updating UI with authentication status:', isAuthenticated);
  
  if (isAuthenticated) {
    document.getElementById('login-btn').classList.add('hidden');
    document.getElementById('logout-btn').classList.remove('hidden');
    document.getElementById('auth-message').classList.add('hidden');
    document.getElementById('search-section').classList.remove('hidden');
  } else {
    document.getElementById('login-btn').classList.remove('hidden');
    document.getElementById('logout-btn').classList.add('hidden');
    document.getElementById('auth-message').classList.remove('hidden');
    document.getElementById('search-section').classList.add('hidden');
  }
}

// Modify loadInitialInvoices
async function loadInitialInvoices() {
  // Reset state for a fresh load (especially relevant when switching tenants)
  currentResults = [];
  window.filteredResults = null; // Clear any previous filters
  currentPage = 1;
  currentApiPage = 1; // Start API fetching from page 1
  apiHasMorePages = true; // Assume more pages initially
  isLoadingMoreApiData = false;
  cachedPages = {}; // Clear cache for the new tenant/load

  // Reset UI filters visually
   document.getElementById('job-status-filter').value = '';
   document.getElementById('search-input').value = '';


  console.log("loadInitialInvoices: Fetching initial page for 'All' filter.");
  toggleLoading(true); // Show loading indicator

  try {
    // Fetch the *first page* (e.g., 100 items)
    const initialData = await fetchInvoicePageApi(1, 100); // Use new helper function

    if (initialData && initialData.invoices.length > 0) {
      currentResults = initialData.invoices; // Store the first batch
      updateAutocompleteSources(currentResults); // Populate suggestions
      apiHasMorePages = initialData.hasMore; // Update based on API response

      console.log(`Fetched initial ${currentResults.length} invoices. API has more: ${apiHasMorePages}`);

      // Display results section and count
      document.getElementById('results-section').classList.remove('hidden');
      document.getElementById('results-count').textContent = `(${currentResults.length} loaded)`; // Indicate loaded count initially

      // Show message about initial load (optional)
       const overdue = currentResults.filter(invoice => getJobStatus(invoice) === 'overdue').length;
       const approaching = currentResults.filter(invoice => getJobStatus(invoice) === 'approaching').length;
       showMessage(`Loaded initial ${currentResults.length} recent invoices (${overdue} deadline, ${approaching} borderline). More may load as you paginate.`, 'info');


      // Sort and display the first client-side page (of 20)
      sortResults(); // sortResults calls displayResultItems which handles pagination

    } else {
      console.log("No initial invoices returned from API.");
      document.getElementById('results-section').classList.add('hidden'); // Hide results if none found
      showMessage("No recent sales invoices found.", 'info');
      apiHasMorePages = false; // No more pages if first fetch is empty
    }
  } catch (error) {
    console.error("Error loading initial invoices:", error);
    showError("Error loading initial invoices: " + error.message);
    document.getElementById('results-section').classList.add('hidden');
  } finally {
    toggleLoading(false); // Hide loading indicator
  }
}

// NEW Helper Function to fetch a single page from Xero API
async function fetchInvoicePageApi(page, pageSize) {
  console.log(`Fetching API page ${page}, size ${pageSize} for tenant ${window.tenantId}`);
  if (!window.tenantId) throw new Error("Tenant ID is not set.");

  const tokens = await getValidTokens();
  if (!tokens) {
    throw new Error('No valid authentication tokens available for API fetch.');
  }

  const url = new URL(`/api/xero-api/invoices`, window.location.origin);
  // --- Default Filters for "All" ---
  // Calculate date 45 days ago for default view if needed, or adjust as required
  const daysAgo = new Date();
  daysAgo.setDate(daysAgo.getDate() - 45); // Adjust lookback period if needed
  const formattedDate = daysAgo.toISOString().split('T')[0];
  const whereClause = `Date>=DateTime(${formattedDate.replace(/-/g, ',')}) AND Type=="ACCREC" AND Status!="PAID"`;

  url.searchParams.set('where', whereClause);
  url.searchParams.set('order', 'Date DESC');
  url.searchParams.set('page', page.toString());
  url.searchParams.set('pageSize', pageSize.toString());
  // --- End Default Filters ---


  try {
    const response = await fetch(url.toString(), {
      headers: {
        'Authorization': `Bearer ${tokens.access_token}`,
        'Xero-Tenant-Id': window.tenantId
      }
    });

    if (!response.ok) {
       const errorText = await response.text();
        try {
           const errorData = JSON.parse(errorText);
            throw new Error(errorData.message || `API Error ${response.status}: ${errorText}`);
        } catch(e) {
             throw new Error(`API Error ${response.status}: ${errorText}`);
        }
    }

    const data = await response.json();
    const invoices = data?.Invoices || [];
    // Determine if more pages likely exist based on whether a full page was returned
    const hasMore = invoices.length === pageSize;
    console.log(`API page ${page} fetch complete. Got ${invoices.length} invoices. HasMore likely: ${hasMore}`);


    return { invoices, hasMore };

  } catch (error) {
    console.error(`Error fetching API page ${page}:`, error);
    // Rethrow or handle as appropriate for the calling function
    throw error; // Let the caller handle the UI feedback
  }
}

function applyJobStatusFilter(statusFilter) {
  // Filter the current results by job status
  const filteredResults = currentResults.filter(invoice => {
    return getJobStatus(invoice) === statusFilter;
  });
  
  // Store filtered results for pagination
  window.filteredResults = filteredResults;
  currentPage = 1;
  
  // Display the filtered results
  displayFilteredResults();
  
}

// Modify displayFilteredResults
function displayFilteredResults() {
  const resultsList = document.getElementById('results-list');
  resultsList.innerHTML = ''; // Clear previous results first

  const loadingElement = document.createElement('div');
  loadingElement.className = 'loading-indicator';
  loadingElement.innerHTML = '<div class="spinner" style="width: 20px; height: 20px;"></div><p>Rendering filtered page...</p>';
  resultsList.appendChild(loadingElement);

  // Update count based on window.filteredResults
  const resultsCount = document.getElementById('results-count');
  const filteredCount = window.filteredResults ? window.filteredResults.length : 0;
  resultsCount.textContent = `(${filteredCount})`; // Show total count for this filter
  console.log(`Displaying filtered results page ${currentPage}. Total for filter: ${filteredCount}`);

  // If no results after filtering
  if (!window.filteredResults || window.filteredResults.length === 0) {
    resultsList.innerHTML = `<div class="message info">No matching invoices found for this filter.</div>`;
    updatePagination(); // Update pagination (will likely show 0 pages)
    return;
  }

  // Generate a cache key for filtered results including tenantId and status
  const jobStatusFilterValue = document.getElementById('job-status-filter').value || 'none'; // Get current status filter
  const cacheKey = `filtered_${window.tenantId}_${currentPage}_${jobStatusFilterValue}`;
  console.log(`Checking cache for filtered key: ${cacheKey}`);


  // Check if we already have this page cached
  if (cachedPages[cacheKey]) {
    console.log('Using cached filtered page:', cacheKey);
    resultsList.innerHTML = cachedPages[cacheKey]; // Replace loading indicator

    // Re-attach click event listeners
    const items = resultsList.querySelectorAll('.result-item[data-id]');
    items.forEach(item => {
      const invoiceId = item.dataset.id;
      if (invoiceId) {
         item.removeEventListener('click', showInvoiceDetailById); // Use named handler
         item.addEventListener('click', showInvoiceDetailById);
      }
    });

     // Restore scroll position or scroll to top
    if (window.lastScrollPosition && currentPage === window.lastPageViewed) {
         console.log(`Restoring scroll position to ${window.lastScrollPosition}`);
         setTimeout(() => window.scrollTo(0, window.lastScrollPosition), 50);
         window.lastScrollPosition = 0;
    } else {
        console.log("Scrolling to top of filtered results.");
        document.getElementById('results-section').scrollIntoView({ behavior: 'smooth' });
    }
    window.lastPageViewed = currentPage;

    // Update pagination controls
    updatePagination();
    return;
  }

  console.log('Cache miss for filtered page, generating:', cacheKey);

  // Calculate pagination based on the *complete* filtered results
  const totalFilteredResults = window.filteredResults.length;
  // Ensure currentPage is valid
   if (currentPage < 1) currentPage = 1;
   const totalPages = Math.ceil(totalFilteredResults / resultsPerPage);
   if (currentPage > totalPages && totalPages > 0) currentPage = totalPages;


  const startIndex = (currentPage - 1) * resultsPerPage;
  const endIndex = Math.min(startIndex + resultsPerPage, totalFilteredResults);
  const pageResults = window.filteredResults.slice(startIndex, endIndex);


  resultsList.innerHTML = ''; // Clear loading indicator

   if (pageResults.length === 0) {
       // This should only happen if filteredResults is empty, handled above
       resultsList.innerHTML = `<div class="message info">No invoices found on this page.</div>`;
       updatePagination();
       return;
   }

  // Display the filtered items for the current page
  const pageContent = document.createDocumentFragment();
  pageResults.forEach(invoice => {
     try {
         const item = createInvoiceItem(invoice); // Use createInvoiceItem
         pageContent.appendChild(item);
     } catch (error) {
         console.error("Error rendering filtered invoice:", error, invoice);
         const errorItem = document.createElement('div');
         errorItem.className = 'result-item message error';
         errorItem.textContent = `Error displaying invoice ${invoice.InvoiceNumber || invoice.InvoiceID || '(Unknown ID)'}`;
         pageContent.appendChild(errorItem);
     }
  });
  resultsList.appendChild(pageContent);


  // Cache this filtered page
  cachedPages[cacheKey] = resultsList.innerHTML;
  console.log('Filtered page cached:', cacheKey);


   // Scroll to top if not restoring scroll position
   if (!window.lastScrollPosition || currentPage !== window.lastPageViewed) {
        console.log("Scrolling to top after generating filtered page.");
      document.getElementById('results-section').scrollIntoView({ behavior: 'smooth' });
   }
   window.lastScrollPosition = 0; // Reset scroll position tracking
    window.lastPageViewed = currentPage;


  // Update pagination controls using the standard function
  updatePagination();
}

// Modify loadInvoicesByStatus
async function loadInvoicesByStatus(status) {
  console.log(`loadInvoicesByStatus called for: ${status}`);
  toggleLoading(true);
  window.filteredResults = null; // Clear previous specific filter results
  currentResults = []; // Clear general results too
  currentPage = 1; // Reset to page 1 for the filter
  cachedPages = {}; // Clear cache for the filter

  try {
    const tokens = await getValidTokens();
    if (!tokens) throw new Error('No valid authentication tokens available');

    let daysToLookBackCalendar;
    let statusName = '';

    // Estimate calendar lookback days needed to capture business days
    if (status === 'overdue') { // >10 business days
      daysToLookBackCalendar = 60; // Look back ~2 months calendar days (adjust as needed)
      statusName = 'deadline';
    } else if (status === 'approaching') { // 7-10 business days
      daysToLookBackCalendar = 30; // Look back ~1 month calendar days (adjust as needed)
       statusName = 'borderline';
    } else {
       throw new Error(`Invalid status provided: ${status}`); // Should not happen
    }

    // Calculate the estimated start date for the API query
    const lookBackDate = new Date();
    lookBackDate.setDate(lookBackDate.getDate() - daysToLookBackCalendar);
    const formattedDate = lookBackDate.toISOString().split('T')[0];

    const url = new URL(`/api/xero-api/invoices`, window.location.origin);
    // Build where clause - non-paid ACCREC within estimated date range
    let whereClause = `Date>=DateTime(${formattedDate.replace(/-/g, ',')}) AND Type=="ACCREC" AND Status!="PAID"`;
    url.searchParams.set('where', whereClause);
    url.searchParams.set('order', 'Date DESC'); // Keep order consistent

    console.log(`Fetching all potential '${statusName}' invoices since ${formattedDate} using fetchAllPages...`);

    // Fetch ALL potential candidates using fetchAllPages
    const allPotentialInvoices = await fetchAllPages(url.toString(), tokens.access_token);

    console.log(`Fetched ${allPotentialInvoices.length} potential invoices. Now filtering by business days...`);


    if (allPotentialInvoices.length > 0) {
      // Apply the precise business day filter *client-side*
      const accuratelyFilteredInvoices = allPotentialInvoices.filter(invoice => {
        return getJobStatus(invoice) === status; // 'overdue' or 'approaching'
      });

      console.log(`Filtered down to ${accuratelyFilteredInvoices.length} actual '${statusName}' invoices.`);

       // Store the *complete* filtered list
      window.filteredResults = accuratelyFilteredInvoices;

      updateAutocompleteSources(window.filteredResults); // Populate suggestions from filtered list


      if (window.filteredResults.length > 0) {
        document.getElementById('results-section').classList.remove('hidden');
        // Display the results count based on the final filtered list
         document.getElementById('results-count').textContent = `(${window.filteredResults.length})`;
        showMessage(`Found ${window.filteredResults.length} ${statusName} invoices.`, 'info');
         // Display the first page of the filtered results
        displayFilteredResults(); // This function paginates window.filteredResults
      } else {
          // No invoices matched the business day criteria after fetching
          window.filteredResults = []; // Ensure it's an empty array
          document.getElementById('results-section').classList.remove('hidden'); // Show section to display message
          document.getElementById('results-list').innerHTML = `<div class="message info">No ${statusName} invoices found matching the criteria.</div>`;
          document.getElementById('results-count').textContent = '(0)';
          document.getElementById('pagination').innerHTML = ''; // Clear pagination
      }

    } else {
      // fetchAllPages returned nothing within the calendar date range
      window.filteredResults = [];
      document.getElementById('results-section').classList.add('hidden');
      showMessage(`No invoices found within the last ${daysToLookBackCalendar} days to check for ${statusName} status.`, 'info');
       document.getElementById('results-count').textContent = '(0)';
       document.getElementById('pagination').innerHTML = ''; // Clear pagination
    }
  } catch (error) {
    console.error(`Error loading invoices by status (${status}):`, error);
    showError(`Error loading ${status} invoices: ${error.message}`);
     document.getElementById('results-section').classList.add('hidden');
  } finally {
    toggleLoading(false);
  }
}

// Modify fetchAllPages to show better progress
async function fetchAllPages(baseUrl, accessToken) {
  let page = 1;
  const pageSize = 100; // Keep Xero page size reasonable
  let allResults = [];
  let hasMorePages = true;
  let initialMessageShown = false;

  // Show initial message only once
  showMessage("Fetching invoices, please wait...", "info");
  initialMessageShown = true;
  toggleLoading(true); // Ensure main loading spinner is visible


  while (hasMorePages) {
    try {
      const url = new URL(baseUrl);
      url.searchParams.set('page', page.toString());
      url.searchParams.set('pageSize', pageSize.toString());

      const response = await fetch(url.toString(), {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Xero-Tenant-Id': window.tenantId
        }
      });

      if (!response.ok) {
         const errorText = await response.text();
         throw new Error(`API Error ${response.status}: ${errorText}`);
      }

      const data = await response.json();
      const invoices = data?.Invoices || [];

      if (invoices.length > 0) {
        allResults = [...allResults, ...invoices];

        // Update progress message periodically
        if (allResults.length % (pageSize * 2) === 0 || invoices.length < pageSize) { // Update every ~200 or on last page
           showMessage(`Fetched ${allResults.length} invoices so far...`, "info");
        }


        hasMorePages = invoices.length === pageSize;
        page++;

        // Optional: Add smaller delay if needed, but focus on user feedback
        // await new Promise(resolve => setTimeout(resolve, 100));

      } else {
        hasMorePages = false;
      }

      // Safety limit (keep or adjust)
      if (allResults.length >= 1000) { // Increased limit slightly, adjust based on typical volume
        showMessage(`Limiting results to ${allResults.length} invoices to optimize performance. Refine search if needed.`, "warning");
        hasMorePages = false;
      }
    } catch (error) {
      console.error(`Error fetching page ${page}:`, error);
       showError(`Error fetching invoice data (page ${page}): ${error.message}. Partial results shown.`); // Inform user
      hasMorePages = false; // Stop fetching on error
    }
  }

  // Hide loading spinner *after* loop finishes or breaks
  toggleLoading(false);
   // Hide the progress message after a short delay
   setTimeout(() => {
       const msgElement = document.getElementById('error-message');
       if(msgElement.textContent.includes("Fetching") || msgElement.textContent.includes("Fetched")) {
           msgElement.classList.add('hidden');
       }
   }, 2000);


  console.log(`fetchAllPages finished. Total fetched: ${allResults.length}`);
  return allResults;
}

// Modify updatePagination
function updatePagination() {
  const pagination = document.getElementById('pagination');
  pagination.innerHTML = ''; // Clear existing buttons

  let resultsToUse;
  let totalResultsCount;
  let totalPages;
  const isJobFilterActive = document.getElementById('job-status-filter').value;
  const isSpecificFilterActive = window.filteredResults !== null && window.filteredResults !== undefined;

  if (isJobFilterActive && isSpecificFilterActive) {
    // Using specific status filter results (Borderline/Deadline)
    resultsToUse = window.filteredResults;
    totalResultsCount = resultsToUse.length;
    totalPages = Math.ceil(totalResultsCount / resultsPerPage);
    console.log(`Pagination: Using filteredResults. Total: ${totalResultsCount}, Pages: ${totalPages}`);
  } else {
    // Using "All" filter results (dynamically loaded)
    resultsToUse = currentResults;
    totalResultsCount = resultsToUse.length; // Count of currently *loaded* items

    // Estimate total pages: If we know there are more pages from the API,
    // calculate pages based on loaded data BUT ensure 'Next' can be shown.
    // If apiHasMorePages is true, we know there's at least one more page than currently loaded data shows.
     if (apiHasMorePages) {
         // Calculate pages based on loaded data, but add 1 conceptually for 'Next' button logic
         totalPages = Math.ceil(totalResultsCount / resultsPerPage) + 1; // Add 1 to ensure 'Next' can appear
         console.log(`Pagination: Using currentResults (API has more). Loaded: ${totalResultsCount}, Estimated Pages: ${totalPages}`);
     } else {
          // API has no more pages, calculate exactly based on loaded data
         totalPages = Math.ceil(totalResultsCount / resultsPerPage);
          console.log(`Pagination: Using currentResults (API complete). Total: ${totalResultsCount}, Pages: ${totalPages}`);
     }

  }

   // Handle case where totalPages might be 0
   if (totalPages <= 1 && !(isJobFilterActive && isSpecificFilterActive) && !apiHasMorePages) {
        console.log("Pagination: Not needed (<= 1 page and API complete or no filter results).");
       return; // No pagination needed if only one page or less and no more API pages
   }


  // Create the pagination container styling (already exists)
  pagination.style.display = 'flex';
  pagination.style.justifyContent = 'center';
  pagination.style.gap = '10px';
  pagination.style.marginTop = '20px';

  // --- Previous Button ---
  const prevButton = document.createElement('button');
  prevButton.textContent = 'Previous';
  prevButton.className = 'btn secondary';
  prevButton.disabled = currentPage === 1; // Disable on first page
  prevButton.addEventListener('click', () => {
    if (currentPage > 1) {
      window.lastScrollPosition = window.scrollY; // Save scroll before navigating
      currentPage--;
      if (isJobFilterActive && isSpecificFilterActive) {
        displayFilteredResults(); // Use filtered display function
      } else {
        displayResultItems(); // Use default display function for "All"
      }
      // Optional transition effect (can be added back if desired)
    }
  });
  pagination.appendChild(prevButton);


  // --- Next Button ---
   const nextButton = document.createElement('button');
   nextButton.textContent = 'Next Page';
   nextButton.className = 'btn primary';

    // Determine if 'Next' should be enabled
    let hasNextPage = false;
    if (isJobFilterActive && isSpecificFilterActive) {
        // For filtered results, enable if current page is less than total calculated pages
        hasNextPage = currentPage < totalPages;
    } else {
        // For "All" results, enable if there are more items loaded than shown OR if API has more pages
        hasNextPage = (currentPage * resultsPerPage < totalResultsCount) || apiHasMorePages;
    }

   nextButton.disabled = !hasNextPage; // Disable if there's no next page

   nextButton.addEventListener('click', () => {
      if (hasNextPage) { // Check again just in case state changed
            window.lastScrollPosition = window.scrollY; // Save scroll
            currentPage++;
             if (isJobFilterActive && isSpecificFilterActive) {
                displayFilteredResults();
            } else {
                 // For "All", displayResultItems will handle fetching more API data if needed
                displayResultItems();
            }
             // Optional transition effect & scroll to top (already in display functions)
       }
   });
   pagination.appendChild(nextButton);
}

function createInvoiceItem(invoice) {
  const item = document.createElement('div');
  item.className = 'result-item';

  // Get job status and add appropriate class
  const jobStatus = getJobStatus(invoice);
  if (jobStatus) {
    item.classList.add(jobStatus);
  }

  // Safety check for invoice ID and set data attribute
  if (invoice.InvoiceID) {
    item.dataset.id = invoice.InvoiceID;
  }

  // Format dates safely
  const date = formatDate(invoice.Date);
  const dueDate = formatDate(invoice.DueDate);

  // Calculate business days from invoice date to now
  const invoiceDate = parseXeroDate(invoice.Date);
  const businessDays = invoiceDate ? getBusinessDaysDifference(invoiceDate, new Date()) : null;

  // Create status badge based on age
  let jobAgeHtml = '';
  if (businessDays !== null) {
    if (businessDays > 10) {
      jobAgeHtml = `<div class="job-age job-overdue">Deadline: ${businessDays} business days</div>`;
    } else if (businessDays >= 7) {
      jobAgeHtml = `<div class="job-age job-approaching">Borderline: ${businessDays} business days</div>`;
    } else {
      jobAgeHtml = `<div class="job-age job-recent">${businessDays} business days</div>`;
    }
  }

  // --- Construct Inner HTML ---
  item.innerHTML = `
    <div class="result-header">
      <div class="invoice-number">Invoice #${invoice.InvoiceNumber || 'N/A'}</div>
      <div class="invoice-status status-${(invoice.Status || '').toLowerCase()}">${invoice.Status || 'Unknown'}</div>
    </div>
    <div class="result-details">
      <div>
        <span>Customer</span>
        <span>${invoice.Contact?.Name || 'N/A'}</span>
      </div>

      <div>
        <span>Reference</span>
        <span>${invoice.Reference || 'N/A'}</span>
        ${ invoice.InvoiceNumber ? `
          <div style="margin-top: 0.25rem;">
            <a href="https://www.dropbox.com/preview/TTL%20Prescription%20copies/${
                (invoice.InvoiceNumber || '').replace('INV-', '') /* Remove prefix */
            }.jpg?role=personal"
               target="_blank"
               rel="noopener noreferrer"
               class="rx-link"  /* Keep class */
               style="font-size: 0.8em; text-decoration: underline; color: var(--primary-color);">
              View RX
            </a>
          </div>
        ` : '' }
      </div>

      <div>
        <span>Date</span>
        <span>${date}</span>
        ${jobAgeHtml}
      </div>
      <div>
        <span>Due Date</span>
        <span>${dueDate}</span>
      </div>
      <div>
        <span>Amount</span>
        <span>${invoice.CurrencyCode || ''} ${invoice.Total ? invoice.Total.toFixed(2) : 'N/A'}</span>
      </div>
    </div>
  `;
  // --- End Inner HTML ---

  // Add main click listener to the whole item for showing details
  if (invoice.InvoiceID) {
    item.addEventListener('click', () => {
        console.log('Result item clicked, showing detail for', invoice.InvoiceID);
        showInvoiceDetail(invoice.InvoiceID);
    });
  }

  // Add specific listener for the RX link to prevent detail view opening
  const rxLink = item.querySelector('.rx-link');
  if (rxLink) {
    // Ensure the listener is attached to the link itself, even if wrapped in a div now
    rxLink.addEventListener('click', (event) => {
      console.log('RX link specifically clicked, stopping propagation.');
      event.stopPropagation();
    });
  }

  return item;
}

/**
 * Extracts the first sequence of exactly 6 digits from a string.
 * @param {string} text The string to search within.
 * @returns {string|null} The 6-digit number as a string, or null if not found.
 */
function extractSixDigitInvoiceNumber(text) {
  if (!text) {
    return null; // Return null if the input is empty or null
  }
  // Regex to find exactly 6 consecutive digits
  const regex = /\d{6}/;
  const match = text.match(regex);

  // Return the first match found, or null otherwise
  return (match && match[0]) ? match[0] : null;
}

async function loadMoreInvoices() {
  try {
    toggleLoading(true);
    currentPage++;
    
    const tokens = await getValidTokens();
    if (!tokens) return;
    
    const url = new URL(`/api/xero-api/invoices`, window.location.origin);
    url.searchParams.set('order', 'Date DESC');
    url.searchParams.set('page', currentPage.toString());
    url.searchParams.set('pageSize', '10');
    
    // Filter for ACCREC only
    url.searchParams.append('where', `Type=="ACCREC"`);
    
    const response = await fetch(url.toString(), {
      headers: {
        'Authorization': `Bearer ${tokens.access_token}`,
        'Xero-Tenant-Id': window.tenantId
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      if (data?.Invoices?.length) {
        // Append new invoices to existing results
        currentResults = [...currentResults, ...data.Invoices];
        displayResults();

        updateAutocompleteSources(currentResults); // Populate suggestions from search results
        
        // Hide "Load More" if fewer results than requested
        document.getElementById('load-more-container').classList.toggle('hidden', data.Invoices.length < 10);
      } else {
        // No more results
        document.getElementById('load-more-container').classList.add('hidden');
      }
    }
  } catch (error) {
    console.error("Error loading more invoices:", error);
  } finally {
    toggleLoading(false);
  }
}

/**
 * Searches Xero for invoices and bills based on various criteria including
 * invoice number, reference, line item description, contact name/email,
 * and contact address (City, PostalCode, Region).
 */
/**
 * Searches Xero for invoices based on search term.
 * Always filters for ACCREC and defaults to last 30 days.
 */
 async function searchInvoices() {
  try {
    // Safely get search term value
    const searchTerm = document.getElementById('search-input')?.value.trim() || '';

    // No longer need to get dateFrom or dateTo

    const tokens = await getValidTokens();
    if (!tokens) throw new Error('No valid authentication tokens available');
    toggleLoading(true);

    // Create base query and headers
    const url = new URL(`/api/xero-api/invoices`, window.location.origin);
    url.searchParams.set('order', 'Date DESC');
    url.searchParams.set('page', '1');
    url.searchParams.set('pageSize', '50'); // Keep fetching a decent size for initial search

    const headers = {
      'Authorization': `Bearer ${tokens.access_token}`,
      'Xero-Tenant-Id': window.tenantId
    };

    // Build where conditions
    const whereConditions = [];

    // Always filter for ACCREC only
    whereConditions.push(`Type=="ACCREC"`);

    // Default to last 30 days for all searches now
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const formattedDate = thirtyDaysAgo.toISOString().split('T')[0];
    whereConditions.push(`Date>=DateTime(${formattedDate.replace(/-/g, ',')})`);

    // Add search term if provided
    if (searchTerm) {
      const safeSearchTerm = searchTerm.replace(/"/g, '\\"');
      const lowerCaseSearchTerm = safeSearchTerm.toLowerCase();

      // Add search condition for the main fields
      whereConditions.push(`(
        (InvoiceNumber!=null AND InvoiceNumber.ToLower().Contains("${lowerCaseSearchTerm}")) OR
        (Reference!=null AND Reference.ToLower().Contains("${lowerCaseSearchTerm}")) OR
        (Contact.Name!=null AND Contact.Name.ToLower().Contains("${lowerCaseSearchTerm}"))
      )`);
    } else {
        // If search term is empty, maybe show a message or rely on the default date range only?
        // Currently, it will just show invoices from the last 30 days.
        console.log("Search term is empty, showing recent invoices (last 30 days).");
    }

    // Combine all conditions with AND
    if (whereConditions.length > 0) {
      const whereClause = whereConditions.join(' AND ');
      url.searchParams.append('where', whereClause);
    }

    // Make the API call
    console.log("Making API request:", url.toString());
    const response = await fetch(url.toString(), { method: 'GET', headers });

    if (!response.ok) {
      const errorText = await response.text();
      try {
        const errorData = JSON.parse(errorText);
        const detail = errorData.Detail || errorData.message ||
          (errorData.Elements && errorData.Elements[0]?.ValidationErrors?.[0]?.Message);
        throw new Error(detail || errorText || `Server returned ${response.status}`);
      } catch (parseError) {
        throw new Error(errorText || `Server returned ${response.status}`);
      }
    }

    const data = await response.json();
    console.log('Xero API response:', data);

     // Process results
     if (data?.Invoices?.length) {
      console.log(`Found ${data.Invoices.length} invoices`);
      currentResults = data.Invoices;
      updateAutocompleteSources(currentResults);
      currentPage = 1;
      window.filteredResults = null; // Reset any specific filter (like job status) when doing a text search

      // Crucially reset API pagination state for the new search results
      currentApiPage = 1;
      apiHasMorePages = data.Invoices.length === 50; // Assume more if full page returned

      displayResults(); // displayResults will handle sorting and rendering the first page

    } else {
      // No results logic...
      currentResults = []; // Clear previous results
      window.filteredResults = null;
      document.getElementById('results-list').innerHTML = ''; // Clear display
      document.getElementById('results-count').textContent = '(0)';
      document.getElementById('pagination').innerHTML = ''; // Clear pagination
      document.getElementById('results-section').classList.remove('hidden'); // Show section to display message
      showMessage('No sales invoices found matching your search criteria.', 'info');
    }
  } catch (error) {
    console.error("Error searching invoices:", error);
    showError(`Error searching sales invoices: ${error.message || 'Unknown error'}`);
     // Clear results display on error too
     currentResults = [];
     window.filteredResults = null;
     document.getElementById('results-list').innerHTML = '';
     document.getElementById('results-count').textContent = '(0)';
     document.getElementById('pagination').innerHTML = '';
     document.getElementById('results-section').classList.remove('hidden'); // Show section to display error message
  } finally {
    toggleLoading(false);
  }
}


// --- Helper functions assumed to exist ---
// async function getValidTokens() { /* ... returns { access_token } or null ... */ }
// function toggleLoading(isLoading) { /* ... shows/hides loading indicator ... */ }
// function showMessage(message, type) { /* ... displays user messages ... */ }
// function showError(message) { /* ... displays error messages ... */ }
// function displayResults() { /* ... renders currentResults to the page ... */ }
// let currentResults = [];
// let currentPage = 1;
// Assume window.tenantId is available


function displaySearchResults(invoices, contacts) {
    const resultsContainer = document.getElementById("search-results");
    resultsContainer.innerHTML = "";

    if ((!invoices || invoices.length === 0) && (!contacts || contacts.length === 0)) {
        resultsContainer.innerHTML = "<p>No results found.</p>";
        return;
    }

    if (invoices && invoices.length > 0) {
        const invoiceList = document.createElement("ul");
        invoiceList.innerHTML = "<h3>Invoices</h3>";
        invoices.forEach(invoice => {
            const item = document.createElement("li");
            item.textContent = `Invoice: ${invoice.InvoiceNumber} - ${invoice.Contact?.Name || 'Unknown Contact'} - ${invoice.Total}`;
            invoiceList.appendChild(item);
        });
        resultsContainer.appendChild(invoiceList);
    }

    if (contacts && contacts.length > 0) {
        const contactList = document.createElement("ul");
        contactList.innerHTML = "<h3>Contacts</h3>";
        contacts.forEach(contact => {
            const item = document.createElement("li");
            item.textContent = `Contact: ${contact.Name} - ${contact.EmailAddress || 'No Email'}`;
            contactList.appendChild(item);
        });
        resultsContainer.appendChild(contactList);
    }
}

function showError(message) {
    const errorContainer = document.getElementById("error-message");
    errorContainer.innerText = message;
    errorContainer.style.display = "block";
}



// Get all recent invoices directly using Xero API
async function getAllInvoices() {
  try {
    // Get valid tokens
    const tokens = await getValidTokens();
    if (!tokens) {
      throw new Error('No valid authentication tokens available');
    }
    
    // Show loading state
    toggleLoading(true);
    
    // Call the Xero API via our serverless function
    const endpoint = 'invoices';
    const params = {
      order: 'Date DESC'
    };
    
// Build URL with parameters
const url = new URL(`/api/xero-api/${endpoint}`, window.location.origin);
    if (params.order) url.searchParams.append('order', params.order);
    
    const response = await fetch(url.toString(), {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${tokens.access_token}`,
        'Xero-Tenant-Id': window.tenantId
      }
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Server returned ${response.status}`);
    }
    
    const data = await response.json();
    console.log('Xero API response for all invoices:', data);
    
    // Process the response
    if (data && data.Invoices && Array.isArray(data.Invoices)) {
      console.log(`Found ${data.Invoices.length} invoices`);
      currentResults = data.Invoices;
      currentPage = 1;
      displayResults();
    } else {
      // Show no results message
      document.getElementById('results-section').classList.add('hidden');
      showMessage('No invoices found. The organization may not have any invoices.', 'info');
    }
  } catch (error) {
    console.error("Error getting invoices:", error);
    showError('Error getting invoices: ' + (error.message || 'Unknown error'));
  } finally {
    toggleLoading(false);
  }
}

// NEW CODE - Replace with this updated function
function displayResults() {
  const resultsList = document.getElementById('results-list');
  
  // Clear results only if it's the first page
  if (currentPage === 1) {
    resultsList.innerHTML = '';
  }
  
  const resultsSection = document.getElementById('results-section');
  const resultsCount = document.getElementById('results-count');
  
  if (!currentResults || currentResults.length === 0) {
    resultsSection.classList.add('hidden');
    showMessage('No invoices found matching your search criteria.', 'info');
    return;
  }
  
  // Show results section
  resultsSection.classList.remove('hidden');
  resultsCount.textContent = `(${currentResults.length})`;
  
  // If it's the first page, sort results
  if (currentPage === 1) {
    // This will sort and display
    sortResults();
  } else {
    // Just display items for current page
    displayResultItems();
  }
  
  // Hide "Load More" button - we'll use our prev/next pagination instead
  document.getElementById('load-more-container').classList.add('hidden');
}

// Function to handle autocomplete logic
function handleAutocomplete() {
  const input = document.getElementById('search-input');
  const suggestionsContainer = document.getElementById('autocomplete-suggestions');
  const value = input.value.trim().toLowerCase();

  if (value.length < 1) { // Minimum characters to trigger autocomplete (adjust if needed)
    suggestionsContainer.innerHTML = '';
    suggestionsContainer.classList.add('hidden');
    return;
  }

  const maxSuggestions = 10;
  let suggestions = [];

  // Filter Invoice Numbers
  // Ensure invoiceNumberSuggestions is an array before using forEach
  if (Array.isArray(invoiceNumberSuggestions)) {
    invoiceNumberSuggestions.forEach(num => {
      // Added check for num existence and ensure it's a string
      if (num && typeof num === 'string' && num.toLowerCase().startsWith(value)) {
        suggestions.push({ type: 'Invoice #', text: num });
      }
    });
  }


  // Filter References (Make sure referenceSuggestions is iterable, e.g., an Array or Set)
  if (typeof referenceSuggestions[Symbol.iterator] === 'function') {
      referenceSuggestions.forEach(ref => {
         // Added check for ref existence and ensure it's a string
        if (ref && typeof ref === 'string' && ref.toLowerCase().startsWith(value) && suggestions.length < maxSuggestions && !suggestions.some(s => s.text === ref)) {
          suggestions.push({ type: 'Reference', text: ref });
        }
      });
  }


  // Filter Contact Names (Make sure contactNameSuggestions is iterable)
  if (typeof contactNameSuggestions[Symbol.iterator] === 'function') {
      contactNameSuggestions.forEach(name => {
          // Added check for name existence and ensure it's a string
        if (name && typeof name === 'string' && name.toLowerCase().startsWith(value) && suggestions.length < maxSuggestions && !suggestions.some(s => s.text === name)) {
          suggestions.push({ type: 'Customer', text: name });
        }
      });
  }


  // Limit total suggestions
  suggestions = suggestions.slice(0, maxSuggestions);

  // Display
  suggestionsContainer.innerHTML = ''; // Clear previous
  if (suggestions.length > 0) {
    suggestions.forEach(suggestion => {
      const div = document.createElement('div');
      // Highlight matching part (optional but nice)
      const matchIndex = suggestion.text.toLowerCase().indexOf(value);
      const highlightedText = matchIndex === 0 // Only highlight if startsWith
         ? `<strong>${suggestion.text.substring(0, value.length)}</strong>${suggestion.text.substring(value.length)}`
         : suggestion.text; // Fallback if something weird happens

      div.innerHTML = `${highlightedText} <span style="color: #888; font-size: 0.8em; float: right;">(${suggestion.type})</span>`;

      // --- MODIFICATION IS HERE ---
      div.addEventListener('click', () => {
        input.value = suggestion.text; // Set input value
        suggestionsContainer.innerHTML = ''; // Clear suggestions
        suggestionsContainer.classList.add('hidden');
        searchInvoices(); // <<<--- ADDED THIS LINE TO TRIGGER SEARCH IMMEDIATELY
      });
      // --- END MODIFICATION ---

      suggestionsContainer.appendChild(div);
    });
    suggestionsContainer.classList.remove('hidden'); // Show container
  } else {
    suggestionsContainer.classList.add('hidden'); // Hide if no matches
  }
}

// Sort the current results
function sortResults() {
  if (!currentResults || currentResults.length === 0) return;
  
  const sortByValue = document.getElementById('sort-by').value;
  
  // Split into field and direction
  const [sortBy, sortOrder] = sortByValue.split('-');
  
  console.log(`Sorting by ${sortBy} in ${sortOrder} order`);
  
  currentResults.sort((a, b) => {
    let valueA, valueB;
    
    // Special handling for dates
    if (sortBy === 'Date' || sortBy === 'DueDate') {
      valueA = parseXeroDate(a[sortBy]);
      valueB = parseXeroDate(b[sortBy]);
      
      // Convert to timestamps for comparison
      valueA = valueA ? valueA.getTime() : 0;
      valueB = valueB ? valueB.getTime() : 0;
    } 
    // Handle nested properties like Contact.Name
    else if (sortBy.includes('.')) {
      const parts = sortBy.split('.');
      valueA = a;
      valueB = b;
      
      // Navigate through the object path
      for (const part of parts) {
        valueA = valueA && valueA[part];
        valueB = valueB && valueB[part];
      }
    } 
    // Regular properties
    else {
      valueA = a[sortBy];
      valueB = b[sortBy];
    }
    
    // Handle undefined values
    if (valueA === undefined) return sortOrder === 'asc' ? -1 : 1;
    if (valueB === undefined) return sortOrder === 'asc' ? 1 : -1;
    
    // Handle different data types
    if (typeof valueA === 'string' && typeof valueB === 'string') {
      return sortOrder === 'asc' 
        ? valueA.localeCompare(valueB) 
        : valueB.localeCompare(valueA);
    } else {
      // Convert to number if possible for numerical comparison
      const numA = parseFloat(valueA);
      const numB = parseFloat(valueB);
      
      if (!isNaN(numA) && !isNaN(numB)) {
        return sortOrder === 'asc' ? numA - numB : numB - numA;
      }
      
      // Fallback comparison
      return sortOrder === 'asc' 
        ? (valueA < valueB ? -1 : valueA > valueB ? 1 : 0)
        : (valueB < valueA ? -1 : valueB > valueA ? 1 : 0);
    }
  });
  

  // Clear and redisplay the results
  const resultsList = document.getElementById('results-list');
  resultsList.innerHTML = '';
  
  // Display results for current page
  displayResultItems();
  
  // Update pagination using our new system
  updatePagination();
}

// Modify displayResultItems
async function displayResultItems() {
  const resultsList = document.getElementById('results-list');
  const jobStatusFilter = document.getElementById('job-status-filter').value; // Check if "All" is active

  // --- Check if more data needs to be fetched from API (ONLY for "All" filter) ---
  const isAllFilterActive = !jobStatusFilter && !window.filteredResults; // Check if we're in the "All" state
  const requiredIndex = (currentPage - 1) * resultsPerPage;

  if (isAllFilterActive && requiredIndex >= currentResults.length && apiHasMorePages && !isLoadingMoreApiData) {
    isLoadingMoreApiData = true; // Set loading flag
    toggleLoading(true); // Show global loading indicator
    showMessage("Loading more invoices from Xero...", "info");
    console.log(`Need data beyond index ${currentResults.length}, fetching API page ${currentApiPage + 1}`);
    try {
      const nextPageData = await fetchInvoicePageApi(currentApiPage + 1, 100);
      currentResults = [...currentResults, ...nextPageData.invoices]; // Append new results
      updateAutocompleteSources(nextPageData.invoices); // Update suggestions with newly loaded page
      currentApiPage++; // Increment API page tracker
      apiHasMorePages = nextPageData.hasMore; // Update hasMore status
      console.log(`Appended ${nextPageData.invoices.length}. Total loaded: ${currentResults.length}. API has more: ${apiHasMorePages}`);
      // Update count display to reflect newly loaded items
      document.getElementById('results-count').textContent = `(${currentResults.length} loaded)`;

    } catch (error) {
      showError(`Failed to load more invoices: ${error.message}`);
      // Decide how to proceed - maybe stop pagination?
      apiHasMorePages = false; // Assume no more can be loaded on error
    } finally {
      isLoadingMoreApiData = false; // Reset loading flag
      toggleLoading(false); // Hide global loading indicator
       // Hide the temporary message after a short delay
       setTimeout(() => {
           const msgElement = document.getElementById('error-message');
           if(msgElement.textContent.includes("Loading more invoices")) {
               msgElement.classList.add('hidden');
           }
       }, 1500);
    }
  }
  // --- End API data fetching logic ---


  // --- Continue with displaying items from currentResults ---
  resultsList.innerHTML = ''; // Clear list before displaying current page

  const loadingElement = document.createElement('div');
  loadingElement.className = 'loading-indicator';
  loadingElement.innerHTML = '<div class="spinner" style="width: 20px; height: 20px;"></div><p>Rendering page...</p>';
  resultsList.appendChild(loadingElement);


  // Use currentResults as the source for "All" filter display
  const resultsToDisplay = currentResults; // Use the potentially updated currentResults

  // Update total count display (reflects loaded count for "All")
  if (isAllFilterActive) {
     document.getElementById('results-count').textContent = `(${resultsToDisplay.length}${apiHasMorePages ? '+ loaded' : ' total'})`;
  } else {
      // Should not happen if called correctly, displayFilteredResults handles other cases
      console.warn("displayResultItems called unexpectedly when a filter might be active.");
      document.getElementById('results-count').textContent = `(${resultsToDisplay.length})`;
  }


  // Generate a cache key including the active tenant ID
  // Cache key might need refinement if mixing API pagination and client pagination
  // For simplicity here, let's cache based on the client page number of loaded data
   const cacheKey = `${window.tenantId}_page_${currentPage}_all`; // Simple key for "All" state
   console.log(`Checking cache for key: ${cacheKey}`);


  // NOTE: Caching with dynamically loaded API pages gets complex.
  // For now, let's *disable caching* when the "All" filter is active to ensure freshness,
  // or implement a more sophisticated cache invalidation strategy.
  // Disabling cache for "All" filter:
  const useCache = !isAllFilterActive; // Only use cache if NOT in "All" state


  if (useCache && cachedPages[cacheKey]) {
     // ... (Keep existing cache logic here if needed for other scenarios, but it's likely displayFilteredResults covers those) ...
     console.log('Using cached page (non-"All" scenario):', cacheKey);
     resultsList.innerHTML = cachedPages[cacheKey];
     // Re-attach listeners etc.
      const items = resultsList.querySelectorAll('.result-item[data-id]');
      items.forEach(item => {
         const invoiceId = item.dataset.id;
         if (invoiceId) {
            item.removeEventListener('click', showInvoiceDetailById);
            item.addEventListener('click', showInvoiceDetailById);
         }
      });

      // Scroll/restore logic...
        if (window.lastScrollPosition && currentPage === window.lastPageViewed) {
            setTimeout(() => window.scrollTo(0, window.lastScrollPosition), 50);
             window.lastScrollPosition = 0;
        } else {
             document.getElementById('results-section').scrollIntoView({ behavior: 'smooth' });
        }
        window.lastPageViewed = currentPage;
        updatePagination(); // Update pagination based on cached view
        return; // Exit
  }

  console.log('Generating page content (cache disabled or miss):', cacheKey);


  // Calculate pagination for the *currently loaded* data in currentResults
  const totalLoadedResults = resultsToDisplay.length;
  const startIndex = (currentPage - 1) * resultsPerPage;
  // Ensure startIndex is valid even if data just loaded
  if (startIndex >= totalLoadedResults && totalLoadedResults > 0) {
      console.warn(`startIndex ${startIndex} is out of bounds for loaded results ${totalLoadedResults}. Resetting to page 1.`);
      currentPage = 1; // Reset to page 1 if out of bounds
      // Re-call displayResultItems to render page 1 correctly? Or adjust startIndex?
      // Safest might be to adjust startIndex for this render pass:
       // startIndex = 0; // Display first page instead
       // Better: Re-trigger display for page 1. Let's adjust start/end for now.
       const adjustedStartIndex = Math.max(0, totalLoadedResults - resultsPerPage); // Show last available page
       const adjustedEndIndex = totalLoadedResults;
       currentPage = Math.floor(adjustedStartIndex / resultsPerPage) + 1; // Update current page number

        console.log(`Adjusted display to page ${currentPage}, startIndex ${adjustedStartIndex}`);
       const pageResults = resultsToDisplay.slice(adjustedStartIndex, adjustedEndIndex);
       resultsList.innerHTML = ''; // Clear loading indicator


        if (pageResults.length === 0 && totalLoadedResults === 0) {
             resultsList.innerHTML = `<div class="message info">No invoices loaded yet.</div>`;
             updatePagination();
             return;
        } else if (pageResults.length === 0) {
             resultsList.innerHTML = `<div class="message info">No invoices found on this page.</div>`;
             updatePagination();
             return;
        }

        // Render adjusted page results
        const pageContent = document.createDocumentFragment();
        pageResults.forEach(invoice => {
             try {
                 const item = createInvoiceItem(invoice);
                 pageContent.appendChild(item);
             } catch (error) { console.error("Error rendering invoice:", error, invoice); /* ... error item ... */ }
         });
         resultsList.appendChild(pageContent);

         // Don't cache this adjusted view? Or cache with the adjusted page number?
         // Let's avoid caching for now when adjustment happens.

          if (!window.lastScrollPosition || currentPage !== window.lastPageViewed) {
             document.getElementById('results-section').scrollIntoView({ behavior: 'smooth' });
          }
          window.lastScrollPosition = 0;
          updatePagination(); // Update pagination based on adjusted reality
          return; // Exit after rendering adjusted page


  } else {
       // Normal path: startIndex is within bounds
       const endIndex = Math.min(startIndex + resultsPerPage, totalLoadedResults);
       const pageResults = resultsToDisplay.slice(startIndex, endIndex);
       resultsList.innerHTML = ''; // Clear loading indicator

        if (pageResults.length === 0 && totalLoadedResults === 0) {
             resultsList.innerHTML = `<div class="message info">No invoices found.</div>`;
             updatePagination();
             return;
         } else if (pageResults.length === 0) {
             // This might happen if currentPage > actual pages available but apiHasMorePages was false
             resultsList.innerHTML = `<div class="message info">No invoices found on this page.</div>`;
             updatePagination();
             return;
         }


       // Create result items for the current page
       const pageContent = document.createDocumentFragment();
       pageResults.forEach(invoice => {
         try {
           const item = createInvoiceItem(invoice);
           pageContent.appendChild(item);
         } catch (error) { console.error("Error rendering invoice:", error, invoice); /* ... error item ... */ }
       });
       resultsList.appendChild(pageContent);


        // Cache if enabled
        if (useCache) {
            cachedPages[cacheKey] = resultsList.innerHTML;
            console.log('Page cached:', cacheKey);
        }

        // Scroll/restore logic...
        if (window.lastScrollPosition && currentPage === window.lastPageViewed) {
            setTimeout(() => window.scrollTo(0, window.lastScrollPosition), 50);
            window.lastScrollPosition = 0;
        } else {
            document.getElementById('results-section').scrollIntoView({ behavior: 'smooth' });
        }
        window.lastPageViewed = currentPage;
  }


  // Update pagination controls AFTER rendering the page
  updatePagination();
}

// Helper function to pass invoiceId to showInvoiceDetail
// Add this helper function alongside others
function showInvoiceDetailById(event) {
    // Find the parent result-item element to get the data-id
    let targetElement = event.target;
    while (targetElement && !targetElement.classList.contains('result-item')) {
        targetElement = targetElement.parentElement;
    }
    const invoiceId = targetElement ? targetElement.dataset.id : null;
    if (invoiceId) {
        showInvoiceDetail(invoiceId);
    } else {
        console.error("Could not find invoice ID for clicked item.");
    }
}

// Update pagination controls
function updatePagination() {
  const pagination = document.getElementById('pagination');
  pagination.innerHTML = '';
  
  const totalPages = Math.ceil(currentResults.length / resultsPerPage);
  
  if (totalPages <= 1) return;
  
  // Previous button
  const prevButton = document.createElement('button');
  prevButton.textContent = '« Previous';
  prevButton.disabled = currentPage === 1;
  prevButton.addEventListener('click', () => {
    if (currentPage > 1) {
      currentPage--;
      displayResults();
    }
  });
  pagination.appendChild(prevButton);
  
  // Page numbers
  const maxButtons = 5; // Maximum number of page buttons to show
  let startPage = Math.max(1, currentPage - Math.floor(maxButtons / 2));
  let endPage = Math.min(totalPages, startPage + maxButtons - 1);
  
  // Adjust if we're near the end
  if (endPage === totalPages) {
    startPage = Math.max(1, endPage - maxButtons + 1);
  }
  
  for (let i = startPage; i <= endPage; i++) {
    const pageButton = document.createElement('button');
    pageButton.textContent = i;
    pageButton.classList.toggle('active', i === currentPage);
    pageButton.addEventListener('click', () => {
      currentPage = i;
      displayResults();
    });
    pagination.appendChild(pageButton);
  }
  
  // Next button
  const nextButton = document.createElement('button');
  nextButton.textContent = 'Next »';
  nextButton.disabled = currentPage === totalPages;
  nextButton.addEventListener('click', () => {
    if (currentPage < totalPages) {
      currentPage++;
      displayResults();
    }
  });
  pagination.appendChild(nextButton);
}

// Show invoice detail
async function showInvoiceDetail(invoiceId) {
  try {
    toggleLoading(true);

    // Get valid tokens
    const tokens = await getValidTokens();
    if (!tokens) {
      throw new Error('No valid authentication tokens available');
    }

    // Fetch the invoice details from Xero API - use absolute URL
    const url = `${window.location.origin}/api/xero-api/invoices/${invoiceId}`;
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${tokens.access_token}`,
        'Xero-Tenant-Id': window.tenantId
      }
    });


    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Server returned ${response.status}`);
    }

    const data = await response.json();
    console.log('Invoice detail:', data);

    if (data && data.Invoices && data.Invoices.length > 0) {
      const invoice = data.Invoices[0];

      // Hide results section and show detail section
      document.getElementById('results-section').classList.add('hidden');
      const detailSection = document.getElementById('detail-section');
      detailSection.classList.remove('hidden');

      const detailElement = document.getElementById('invoice-detail');

      // Format dates safely
      const date = formatDate(invoice.Date);
      const dueDate = formatDate(invoice.DueDate);

      // Build line items HTML safely
      const lineItemsHtml = (invoice.LineItems || []).map(item => `
        <tr>
          <td>${item.Description || 'N/A'}</td>
          <td>${item.Quantity || 0}</td>
          <td class="text-right">${invoice.CurrencyCode || ''} ${item.UnitAmount ? item.UnitAmount.toFixed(2) : '0.00'}</td>
          <td class="text-right">${invoice.CurrencyCode || ''} ${item.LineAmount ? item.LineAmount.toFixed(2) : '0.00'}</td>
        </tr>
      `).join('');

      // --- START: Extract 6 Digits from INVOICE NUMBER for Lab Form Link ---
      const invoiceNumberForLink = invoice.InvoiceNumber || '';
      const extractedLabFormNumber = extractSixDigitInvoiceNumber(invoiceNumberForLink); // Use the helper
      let labFormDropboxLink = '#'; // Default invalid link
      if (extractedLabFormNumber) {
          labFormDropboxLink = `https://www.dropbox.com/preview/TTL%20Prescription%20copies/${extractedLabFormNumber}.jpg?role=personal`;
      }
      // --- END: Extract 6 Digits ---

      // Build the detail view HTML
      detailElement.innerHTML = `
        <div class="invoice-header">
          <h2>Invoice #${invoice.InvoiceNumber || 'N/A'}</h2>
          <div class="invoice-status status-${(invoice.Status || '').toLowerCase()}">${invoice.Status || 'Unknown'}</div>
        </div>

        <div class="invoice-meta">
          <div class="invoice-meta-group">
            <h3>Details</h3>
            <div><strong>Date:</strong> ${date}</div>
            <div><strong>Due Date:</strong> ${dueDate}</div>
            <div><strong>Reference:</strong> ${invoice.Reference || 'N/A'}</div>
            <div><strong>Type:</strong> ${invoice.Type || 'N/A'}</div>
          </div>

          <div class="invoice-meta-group">
            <h3>Customer</h3>
            <div>
                <strong>Name:</strong> ${invoice.Contact?.Name || 'N/A'}
            </div>
            <div>
                <strong>Address:</strong>
                <div class="address-block">
                    ${ invoice.Contact?.Addresses?.[0] ? `
                        <span>${invoice.Contact.Addresses[0].AddressLine1 || ''}</span>
                        ${invoice.Contact.Addresses[0].AddressLine2 ? `<span>${invoice.Contact.Addresses[0].AddressLine2}</span>` : ''}
                        <span>
                            ${invoice.Contact.Addresses[0].City || ''}${invoice.Contact.Addresses[0].City && invoice.Contact.Addresses[0].Region ? ', ' : ''}${invoice.Contact.Addresses[0].Region || ''} ${invoice.Contact.Addresses[0].PostalCode || ''}
                        </span>
                        ${invoice.Contact.Addresses[0].Country ? `<span>${invoice.Contact.Addresses[0].Country}</span>` : ''}
                    ` : '<span>N/A</span>' }
                </div>
            </div>
          </div>

          ${ extractedLabFormNumber ? `
<div>
  <strong>Lab Form:</strong>
  <div style="margin-top: 0.2rem;">
    <a href="https://www.dropbox.com/preview/TTL%20Prescription%20copies/${
        (invoice.InvoiceNumber || '').replace('INV-', '') /* Keep prefix removal */
    }.jpg?role=personal"
       target="_blank"
       rel="noopener noreferrer"
       style="text-decoration: underline; color: var(--primary-color); font-size: 0.9rem;">
      View lab form
    </a>
  </div>
</div>
            </div>
          ` : '' }

        </div>

        <div class="invoice-items">
          <h3>Line Items</h3>
          <table>
            <thead>
              <tr>
                <th>Description</th>
                <th>Quantity</th>
                <th class="text-right">Unit Price</th>
                <th class="text-right">Amount</th>
              </tr>
            </thead>
            <tbody>
              ${lineItemsHtml}
            </tbody>
            <tfoot>
              <tr>
                <td colspan="3" class="text-right"><strong>Subtotal</strong></td>
                <td class="text-right">${invoice.CurrencyCode || ''} ${invoice.SubTotal ? invoice.SubTotal.toFixed(2) : '0.00'}</td>
              </tr>
              <tr>
                <td colspan="3" class="text-right"><strong>Total Tax</strong></td>
                <td class="text-right">${invoice.CurrencyCode || ''} ${invoice.TotalTax ? invoice.TotalTax.toFixed(2) : '0.00'}</td>
              </tr>
              <tr class="total-row">
                <td colspan="3" class="text-right"><strong>Total</strong></td>
                <td class="text-right">${invoice.CurrencyCode || ''} ${invoice.Total ? invoice.Total.toFixed(2) : '0.00'}</td>
              </tr>
            </tfoot>
          </table>
        </div>
      `; // End of innerHTML assignment

    } else {
      showError('Invoice not found');
    }
  } catch (error) {
    console.error('Error getting invoice details:', error);
    showError('Error loading invoice details. Please try again.');
  } finally {
    toggleLoading(false);
  }
}

// Global variables
let currentResults = [];
let currentPage = 1;
let cachedPages = {};
const resultsPerPage = 20; // Keep this

// --- Autocomplete State ---
let invoiceNumberSuggestions = [];
let referenceSuggestions = new Set();
let contactNameSuggestions = new Set();
let autocompleteDebounceTimer;
const DEBOUNCE_DELAY = 300; // milliseconds
// --- End Autocomplete State ---

// --- NEW STATE VARIABLES ---
let currentApiPage = 1; // Track the last API page fetched for "All" filter
let apiHasMorePages = true; // Track if the API likely has more pages for "All"
let isLoadingMoreApiData = false; // Prevent multiple simultaneous API fetches
// --- END NEW STATE VARIABLES ---

// Helper function to parse Xero date format
function parseXeroDate(xeroDateString) {
  if (!xeroDateString) return null;
  
  // Check if it's in the Xero JSON format \/Date(timestamp)\/
  const dateRegex = /\/Date\((\d+)(?:[-+]\d+)?\)\//;
  const match = dateRegex.exec(xeroDateString);
  
  if (match && match[1]) {
    // Extract the timestamp and create a date
    return new Date(parseInt(match[1], 10));
  }
  
  // If we have a DateString property available (ISO format)
  if (typeof xeroDateString === 'string' && xeroDateString.includes('T')) {
    return new Date(xeroDateString);
  }
  
  // Fallback - try direct parsing
  const directDate = new Date(xeroDateString);
  if (!isNaN(directDate.getTime())) {
    return directDate;
  }
  
  return null;
}

// Debounce function
function debounce(func, delay) {
  return function(...args) {
    clearTimeout(autocompleteDebounceTimer);
    autocompleteDebounceTimer = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// Function to update suggestion sources from current data
function updateAutocompleteSources(invoices) {
  if (!invoices || invoices.length === 0) return;

  // Clear previous sources for this batch/filter
  // Note: For the "All" filter with API pagination, decide if you want suggestions
  // to *only* reflect loaded data or accumulate across loads. Accumulating is simpler here.
  // If clearing per batch:
  // invoiceNumberSuggestions = [];
  // referenceSuggestions.clear();
  // contactNameSuggestions.clear();

  invoices.forEach(invoice => {
    if (invoice.InvoiceNumber) {
      // Invoice numbers are usually unique, array is fine
      if (!invoiceNumberSuggestions.includes(invoice.InvoiceNumber)) {
          invoiceNumberSuggestions.push(invoice.InvoiceNumber);
      }
    }
    if (invoice.Reference) {
      referenceSuggestions.add(invoice.Reference);
    }
    if (invoice.Contact?.Name) {
      contactNameSuggestions.add(invoice.Contact.Name);
    }
  });

  // Optional: Sort suggestions for better display
  invoiceNumberSuggestions.sort();
  // Convert sets to arrays for easier filtering later if needed, or filter directly
  // console.log('Autocomplete sources updated');
}

// Format date safely for display
function formatDate(dateValue) {
  if (!dateValue) return 'N/A';
  
  const date = parseXeroDate(dateValue);
  if (!date || isNaN(date.getTime())) {
    return 'N/A';
  }
  
  return date.toLocaleDateString();
}

// Initialize the application when the document is ready
document.addEventListener('DOMContentLoaded', initApp);

// Calculate business days between two dates (excluding weekends)
function getBusinessDaysDifference(startDate, endDate) {
  if (!startDate || !endDate) return null;
  
  // Convert to date objects if they aren't already
  const start = startDate instanceof Date ? startDate : new Date(startDate);
  const end = endDate instanceof Date ? endDate : new Date(endDate);
  
  // Validate dates
  if (isNaN(start.getTime()) || isNaN(end.getTime())) return null;
  
  // Calculate days, excluding weekends
  let count = 0;
  let current = new Date(start);
  
  while (current <= end) {
    // Skip weekends (0 = Sunday, 6 = Saturday)
    const dayOfWeek = current.getDay();
    if (dayOfWeek !== 0 && dayOfWeek !== 6) {
      count++;
    }
    
    // Move to next day
    current.setDate(current.getDate() + 1);
  }
  
  return count;
}

// Determine job status based on age (business days)
// Update the getJobStatus function to log details for debugging
function getJobStatus(invoice) {
  // Skip paid invoices for job status categorization
  if (invoice.Status === 'PAID') {
    return null;
  }
  
  // Skip ACCPAY invoices
  if (invoice.Type === 'ACCPAY') {
    return null;
  }
  
  // Use invoice date as start date
  const startDate = parseXeroDate(invoice.Date);
  if (!startDate) {
    console.log("Invalid date for invoice:", invoice.InvoiceNumber);
    return null;
  }
  
  // Use current date as end date
  const endDate = new Date();
  
  // Calculate business days difference
  const businessDays = getBusinessDaysDifference(startDate, endDate);
  if (businessDays === null) {
    console.log("Couldn't calculate business days for invoice:", invoice.InvoiceNumber);
    return null;
  }
  
  // Log for debugging
  console.log(`Invoice ${invoice.InvoiceNumber}: ${businessDays} business days`);
  
  // Determine status based on business days
  if (businessDays > 10) {
    return 'overdue';
  } else if (businessDays >= 7) {
    return 'approaching';
  } else {
    return 'recent';
  }
}



  </script>
</body>
</html>  